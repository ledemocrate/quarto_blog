{
  "hash": "9e8dceb73062bc701d3f1dcaf31c28c6",
  "result": {
    "markdown": "---\ntitle: \"Formation DATA\"\nsubtitle: \"Utilisation d'un ETL : Talend Open Studio\"\nauthor:\n    name: GOLLENTZ Quentin\n    url: https://www.linkedin.com/in/quentin-gollentz-697993172/\n    email: quentin.gollentz@daka-team.com\n    affiliations:\n        name: DAKA-TEAM\n        url: https://www.linkedin.com/company/daka%E2%80%A2tec/\n        city: Lille\n        state: France\n        postal-code: 5900\ndate: last-modified\ndate-format: \"DD-MM-YYYY\"\ndescription: \"Application sur l'Open Data de l'Assemblée Nationale\"\ntitle-block-banner: \"#ECF4FA\"\nformat: \n  html:\n    code-fold: true\n    embed-resources: true\n    smooth-scroll: true\n    theme: cosmo\n    fontcolor: black\n    toc: true\n    toc-location: left\n    toc-title: Summary\n    toc-depth: 3\n    html-math-method: katex\ncss: css/styles.css\nbibliography: references.bib\nengine: knitr\n---\n\n::: {.cell}\n<style type=\"text/css\">\n.column {\ntext-align: center;\n}\n</style>\n:::\n\n::: {.cell}\n<style type=\"text/css\">\n.justify {\n  text-align: justify !important\n}\n</style>\n:::\n\n\n# 0. Introduction et prérequis\n\n::: {.justify}\n\nDans la suite du document, nous proposons des exercices qui sont liés les uns des autres.\\\nIl est donc nécessaire de suivre dans l'ordre le document car certains exercices sont conditionnés aux précédents.\\\nNous proposons le traitement de données issu de l'[Open Data de l'Assemblée Nationale](https://data.assemblee-nationale.fr/), en vue de développer une API permettant d'obtenir les informations relatives à un député.\n\nPour la réalisation des exercices, il sera nécessaire d'avoir :\n\n-   Talend en version 7.3.1 pour faire des traitements informatiques\n-   Notepad++ pour visualiser et éditer des fichiers\n-   Dbeaver pour interagir avec une base de données\n-   PostgreSQL pour disposer d'une base de données\n-   Postman pour interagir avec des API\n-   Connexion internet\n-   Une compréhension basique de l'anglais technique\n-   Une compréhension basique de la science des données\n-   Une compréhension basique de l'informatique décisionnelle\n\n:::\n\n# 1. Présentation\n\n## 1.1 Présentation du principe ETL\n\n::: {.justify}\n\n**L'ETL est un acronyme pour EXTRACT TRANSFORM AND LOAD.**\n\nC'est un concept signifiant le chargement de données d'un point A vers un point B ou les données de A sont éventuellement transformé afin d'être chargés dans B.\\\nUn logiciel ETL (Extract, Transform, Load) permet d'extraire des données brutes depuis une base de données, pour ensuite les restructurer, et enfin les charger.\\\nLes premiers ETL ont fait leur apparition dans les années 1970, mais ont beaucoup évolué pour répondre aux nouveaux besoins liés à l'essor du Cloud, des [SaaS (logiciels en tant que service)](https://www.lebigdata.fr/definition-saas) et du Big Data.\\\nDésormais, les ETL doivent permettre l'ingestion en temps réel, l'enrichissement de données, la prise en charge de milliards de transactions. Ils prennent aussi en charge les données structurées ou non structurées en provenance de sources sur site ou sur le Cloud.\\\nDe même, ces plateformes doivent désormais être scalables, flexibles, résistantes aux pannes, et sécurisées.\n\nLa différence entre l’ETL et l’ELT réside dans le fait que les données sont transformées en informations décisionnelles et dans la quantité de données conservée dans les entrepôts.\n\n-   L’ETL (Extract/Transform/Load) est une approche d’intégration qui recueille des informations auprès de sources distantes, les transforme en formats et styles définis, puis les charge dans des bases de données, sources de données ou entrepôts.\n\n![](img/ETL.png)\n\n\n\n-   L’ELT (Extract/Load/Tansform) extrait également des données à partir d’une ou plusieurs sources distantes, mais les charge ensuite dans l’entrepôt de données cible sans changement de format. Dans un processus ELT, la transformation des données s’effectue au sein de la base de données cible. L’ELT nécessite moins de sources distantes, uniquement leurs données brutes et non préparées.\n\n![](img/ELT.png)\n\n\nLes deux approches sont viables, mais les décideurs informatiques, lorsqu’ils créent une architecture de données, doivent prendre en compte les capacités internes et l’impact croissant des technologies Cloud.\n\n**Talend est donc un logiciel ETL de manière simplifier afin que le développeur ne s'occupe que de la partie règle de métier.**\n\n:::\n\n## 1.2 Présentation d'un WORKSPACE\n\n::: {.justify}\n\n[Les projet Talend sont stockés dans un espace de travail (workspace)](https://business-intelligence.developpez.com/faq/talend/?page=I).\n\nChaque projet Talend contient un ensemble de Jobs (traduit sous forme de \"classe\"), ces jobs Talend sont stockés dans un projet Talend.\n\nCi-dessous, vous verrez l'arborescence d'un projet Talend :\n\n-   workspace\n    -   projet1\n        -   businessProcess (les Business Models)\n        -   code (les Routines)\n        -   configuration (les fichiers de configuration)\n        -   context (les contextes)\n        -   documentations (les documentations créés dans les jobs)\n        -   images (les images des tMap par exemple)\n        -   joblets (les joblets pour les version TIS)\n        -   metadata (les metadata)\n        -   process (les jobs)\n        -   sqlPatterns (les patterns sql)\n        -   temp (les fichiers temporaires)\n    -   projet2\n        -   businessProcess\n        -   code\n        -   ...\n\nAvant de créer son premier WORKSPACE, il convient de lancer Talend Studio.\\\nEn supposant que les étapes précédentes ont été respectées, il convient de :\\\n\n-   Se rendre dans ce chemin : *C:/ESB_731/Studio*        \n-   Faire un double clic gauche sur l'exécutable ***TOS_ESB-win-x86_64.exe*** afin de démarrer Talend Studio.\n\n:::{.callout-tip}\n\n## Recommandation\n\nIl est recommandé de créer un raccourci vers l'exécutable dans son Bureau afin d'éviter une navigation inutile.       \nRappel : CTRL+C sur l'exécutable puis CTRL+V sur le Bureau\n:::\n\nÀ l'exécution vous devriez avoir la fenêtre suivante qui s'ouvre :\n\n![](img/demarrage_talend.png) Par défaut, le WORKSPACE sera situé dans le chemin suivant :\n\n-   *C:/ESB_731/Studio/workspace*\n\nPour pouvoir changer d'endroit, il convient de :\n\n-   Cliquer sur : Gérer les connexions\n-   Dans la partie Espace de travail : Mettre le chemin souhaité\n\n![](img/set_workspace_path.png)\n\n:::\n\n## 1.3 Présentation de TALEND OPEN STUDIO\n\n::: {.justify}\n\nRappel commande utile :\n\n-   CTRL + A : Tout sélectionner\n-   CTRL + C : Copier\n-   CTRL + V : Coller\n-   CTRL + Z : Revenir à l'état précédant une action\n-   CTRL + Y : Revenir à l'état succédant une action\n-   CTRL + S : Sauvegarder\n\n:::\n\n### BARRE PRINCIPALE\n\n::: {.justify}\n\n![](img/barre_principale.png)\n\n-   FICHIER : Permets de changer de WORKSPACE et de modifier les propriétés du projet \n-   EDITER : Revenir en arrière, Copier, Coller, ect… \n-   FENÊTRE : \n    -   Modifier les éléments visuels du Studio \n    -   Modifier l’ensemble des paramètres pour les jobs du projet dans l'onglet [Préférences](https://help.talend.com/r/fr-FR/7.3/open-studio-user-guide/java-interpreter-path-talend) \n\n:::\n\n### QUADRANT NORD OUEST {#quad-no}\n\n::: {.justify}\n\n![](img/quadrant_nord_ouest.png) \n    \n-   BUSINESS MODELS : (Aucune idée de l’utilité ou non)       \n-   JOBS : L’endroit où l’on peut retrouver les différents JOB, par JOB on entend un traitement de données.       \n-   ROUTES : La principale différence entre les ROUTES et les JOB est que lorsque vous démarrez une route, elle écoute ou STREAM indéfiniment les entrées (fichier, message, etc.), et chaque fois qu'elles sont disponibles, elles sont traitées et envoyées à destination, jusqu'à ce que la route soit arrêtée.         \nD'autre part, un JOB est un processus par lots ou BATCH qui est lancé à la demande pour gérer certaines entrées (fichiers, base de données, etc.) et se termine lorsque toutes les entrées sont traitées.   \n\n:::{.callout-tip}\n\n## Utile\n\nUn point important à noter est que vous pouvez appeler des Jobs Talend à partir d'une Route Talend si vous le souhaitez.\n:::\n\n-   SERVICES : Un webservice est une fonction qui a pour rôle de mettre un disposition un service via internet. Le webservice est une interface entre deux applications, et leur permet tout comme l’API, de communiquer entre elles.         \nLe webservice permet à des applications de communiquer entre elles même si elles fonctionnent avec des langages différents. Les webservices les plus connus sont de types SOAP, REST et HTTP.         \nFonctionnement d’un webservice\n    -   **Étape 1** : Un utilisateur sur un ordinateur ou un mobile fait une demande. On l’appelle le client. Sa demande représente une requête qui est envoyée dans un langage spécfique : XML, HTTP ou encore JSON.\n    -   **Étape 2** : La requête issue du client est envoyée sur un serveur distant via un protocole de type SOAP, REST ou HTTP.\n    -   **Étape 3** : Le serveur va émettre une réponse qui aura le même format que celui du protocole de la demande.       \n-   CONTEXTE : L’endroit où l’on peut retrouver les variables de contexte qui sont disponibles à l’exécution du JOB que l’on oppose aux variables globales qui sont disponibles dans le JOB.       \nCes variables peuvent être regroupées dans une catégorie qu'on appelle GROUPE et peuvent prendre leurs valeurs en fonction d'un ENVIRONNEMENT.        \n\n-   RESSOURCE : (Aucune idée de l’utilité ou non)                \n-   CODE : Permets de faire du code Java que l’on pourra réutiliser, on appelle ce code ROUTINES.  \n\n:::{.callout-note}\n## Note\n\nPar défaut un certain de nombre de ROUTINES sont disponibles :   \n\n-   Mathematical : Permet de faire des opérations mathématiques sur des entiers ou des numeriques\n-   TalendDate : Permet de faire des opérations sur des dates\n-   StringHandling : Permet de faire des opérations sur des chaines de charactères\n:::\n\n-   MODEL SQL : (Aucune idée de l’utilité ou non)       \n-   METADONNE : L’endroit où l’on stocke les **metadata** des diverses sources ou cibles de données possibles.      \nOn peut faire remarquer que ces **metadata** peuvent être paramètrées par des variables de contextes :       \n    -   BDD       \n    -   Fichier Délimité        \n    -   Fichier JSON        \n    -    …       \n\n:::        \n\n### QUADRANT NORD EST {#quad-ne}\n\n::: {.justify}\n\n![](img/quadrant_nord_est.png)        \n    \nL'endroit où nous allons créer les jobs qui prennent généralement des sources de données effectue des transformations en vue de les mettre dans une autre ou la même source de données.\\\n\nCette partie ne prend sens uniquement lorsqu'un JOB est ouvert.   \n    \nOn importe des composants :       \n\n- Via la palette à droite\n- En cliquant n'importe où dans la fenêtre puis en écrivant le nom du composant que l'on souhaite importer.       \nPar exemple : **tFileInputDelimited**\n    \nDans l'onglet Code, on peut voir le code du job.        \nCelui-ci n'est là qu'à titre informatif et ne peut être modifié, il permet néanmoins de détecter d'éventuel erreur de compilation. \n\n:::{.callout-warning}\n\n## Attention\n\nSeule l’onglet Designer permet de développer.  \nNe permet de détecter les erreurs qui peuvent se produire dans l'éxécution du job\n:::\n\n![](img/quadrant_nord_est_bis.png)        \n:::\n\n\n### QUADRANT SUD OUEST {#quad-so}\n\n::: {.justify}\n\n![](img/quadrant_sud_ouest.png)\n\n-   APERCU DU CODE : (Aucune idée de l’utilité ou non)\n-   OUTLINE : Ne prend sens que dans le cas où un JOB est ouvert.        \nOn retrouve ici l'ensemble des composants utilisés dans le JOB ouvert et les variables globales que ces composants génèrent.        \nCes variables peuvent être disponible avant ou pendant l’exécution du composant.\n\n:::{.callout-tip}\n\n## Utile\n\nLes variables globales définis par les composants, peuvent être appelés une fois qu'elle ont été définis dans d'autres composants.       \n:::\n\n:::\n\n### QUADRANT SUD EST {#quad-se}\n\n::: {.justify}\n\n-   COMPOSANT : Ne prend sens que dans le cas où un JOB est ouvert et qu’on a cliqué sur un composant.         \nDans cette fenêtre, nous allons paramétrer le composant afin que celui fonctionne selon nos besoins\n![](img/quadrant_sud_est_2.png)\n\n\n-   CONTEXT : Permet de visualiser et de gérer l’ensemble des variables de contexte utilisés dans le JOB\n![](img/quadrant_sud_est_3.png)\n\n\n-   EXECUTER LE JOB : Ne prend sens que dans le cas où un JOB est ouvert, il permet d’exécuter le traitement et d’afficher ce qui arrive dans la console.       \nUne exécution en mode DEBUG est possible; une telle exécution permet d’afficher l’ensemble des variables utilisées par le programme et leurs valeurs à l’instant T.        \nIl est également dans ce mode DEBUG de faire une pause dans le traitement.\nDeux types d'erreur peuvent se produire :       \n    -   Les erreurs de **compilation** sont la conséquence d'un code mal écrit et se manifeste lors de la construction du job.       \n    -    Les erreurs dans l'**éxécution**  sont la conséquence d'un code mal écrit ou mal définis et se manifeste lors de l'éxécution du job. \n\n\n![](img/quadrant_sud_est_1.png)\n\n:::\n\n## 1.4 Présentation d'un JOB\n\n::: {.justify}\n\nUn job peut être vu comme un ensemble de composants liés les uns aux autres et se lit de gauche à droite puis du haut vers le bas ; à la manière de la lecture française.\n\nLes liens entre composants peuvent être de différentes natures :        \n\n-   **Row** : Les lignes sont transférés de la sortie d'un composant à l'entrée d'un autres composant\n    -   *Main* : L'ensemble des lignes sont transférés\n    -   *Iterate* : Chaque ligne passe dans le composant de façon itérative\n-   **Trigger** : Le composant s'éxécute en fonction d'une condition testé à la fin de l'éxécution d'un autres composants\n    -   *On Component OK/ERROR* : Le composant s'éxecute en fonction de si le composant précédent à réussi ou pas\n    -   *On Subjob OK/ERROR* : Le composant s'éxecute en fonction de si le sous-job précédent càd une suite de composant lié en mode **Row** à réussi ou pas\n    -   *If* : Le composant s'éxécute en fonction d'une condition qui retourne TRUE ou FALSE.\n\n:::{.callout-note}\n\n## Convention\n\nOn parle de sous-job lorsqu'une suite de composant est lié par des liens de type **Row**\n:::\n\nPar convention, on lit les composants de gauche à droite lorsque le lien est de type **Row** et de haut en bas lorsque le lien est de type **If**\n\nUn [composant](https://www.axysweb.com/le-lexique-pour-comprendre-et-utiliser-le-studio-talend/) est un sous-ensemble d'un job qui effectue une opération définie. Par exemple : lire un fichier, filtrer des données ou encore extraire des données.\n\nUn composant est composé d’un extrait de code Java généré automatiquement. Le but des composants est de gagner du temps en évitant le codage manuel pour effectuer les opérations de traitement de données courantes.\n\nTalend propose une multitude de composants prêts à emploi regroupés un répertoire. Il est possible de développer des composants sur-mesure si Talend ne propose aucun composant répondant à votre besoin.\n\nCes composants nécessitent un paramétrage, le paramétrage peut être définis selon deux façons :        \n\n- **En dure** dans le sens où les valeurs associé aux paramètres du composant est définis par une valeur fixe écrit par le développeur\n- **Avec variable** dans le sens où les valeurs associé aux paramètres du composant est définis par une valeur porté par une variable :\n    - *contexte* : Disponible à l’exécution du job\n    - *globale* : Définis dans le job\n\nLes variables de contexte sont souvent utilisée pour porter les paramétrages de composant.\nCes variables de contexte peuvent être regroupés dans un **GROUPE** et les valeurs portés par ces variables peuvent être définis en fonction d'**ENVIRONNEMENT**.       \nGénéralement, on définis au moins trois environnement.         \nPrenons l'exemple d'un job visant à alimenter une BDD, on définis un groupe de contexte visant à porter les paramètres pour s'y connecter, on définit trois environnements :               \n\n-   **DEV** :  BDD sur son poste permettant de faire son développement\n-   **QUAL** : BDD sur un serveur dédié visant à simuler un traitement opérationnelle\n-   **PROD** : BDD opérationnel\n\nCertain composant peuvent être paramétrer via le concept de **metadata**, ce qui permet la réutilisation du composant avec le paramétrage associé.        \nOn oppose ce concept de **metada** au fait de paramétrer le composant dans le job lui-même.\n\nCertains paramétrages peut être fait de façon partiellement automatique ou à la main.\nC'est le cas notamment des composants de lecture de fichier, par exemple **tFileInputDelimited**\n\n- **À la main** : \n  - AVANTAGE : CONTROLE \n  - DESAVANTAGE : VITESSE\n- **Automatique** : \n  - AVANTAGE : VITESSE \n  - DESAVANTAGE : CONTROLE\n  \n:::{.callout-tip}\n\n## Recommandation\n\nIl est recommandé de laisser Talend définir les **metadata** et de corriger le résultat si celui-ci ne convient pas\n:::\n\n:::\n\n# 2. Installation des outils\n\n## 2.1 TALEND\n\n::: {.justify}\n\n-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :\n    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)\n-   **Etape 1** : Télécharger l'archive ***ESB_731.7z***\n-   **Etape 2** : Extraire l'archive téléchargée précédemment à la racine du disque *C:/*\n\nÀ la fin de ces étapes, vous devriez obtenir le dossier suivant :\n\n![](img/resultat_installation_talend.png)\n\nÉgalement les sous-dossiers suivants :\n\n![](img/resultat_installation_talend_subfolder.png)\n\n:::\n\n## 2.2 JAVA\n\n::: {.justify}\n\nTalend peut être vu comme un générateur de code Java, ainsi il est donc nécessaire de disposer d'une version de machine java adapté à la version de Talend utilisé.\n\n-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :\n    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)\n-   **Etape 1** : Télécharger l'archive ***jdk-20.zip***\n-   **Etape 2** : Extraire l'archive téléchargée précédemment à la racine du disque *C:/*\n-   **Etape 3** : Lancer une invite de commande (Rappel : cmd dans une fenêtre)\n-   **Etape 4** : Lancer les commandes suivantes :\n    -   `set PATH=C:\\jdk-20\\bin;%PATH%`       \n        `java -version`       \n        `where java`        \n\nÀ la fin de ces étapes, vous devriez obtenir le résultat suivant :\n\n![](img/resultat_installation_java.png)\nUne autre solution est de spécifier le JAVA a utilisé par TALEND.       \n\n-   **Etape 0** : Se rendre dans le dossier d'installation suivant suivant *C:/ESB_731* :\n-   **Etape 1** : Ouvrir le fichier `TOS_ESB-win-x86_64.ini` \n-   **Etape 2** : A début du fichier ajouter les deux lignes suivnantes : \n    -   `-vm`       \n        `C:\\Program Files\\Java\\jdk-20\\bin`       \n\nÀ la fin de ces étapes, vous devriez obtenir le résultat suivant :\n\n![](img/resultat_installation_java_2.png)\n\n:::\n\n## 2.3 NOTEPAD++\n\n::: {.justify}\n\n-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :\n    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)\n-   **Etape 1** : Télécharger l'archive ***Notepad++.7z***\n-   **Etape 2** : Extraire l'archive téléchargée précédemment à la racine du disque *C:/*\n\nÀ la fin de ces étapes, vous devriez obtenir le résultat suivant :\n\n![](img/resultat_installation_notepad.png)\n\nÉgalement les sous-dossiers suivants :\n\n![](img/resultat_installation_notepad_subfolder.png)\n\nOn peut également télécharger des add-ons à Notepad :       \n\n-   JSON Viewer : Pour mieux visualiser des fichiers JSON\n-   XML Tools : Pour mieux visualiser des fichiers XML\n\nPour pouvoir installer un add-on, il convient de :        \n\n-   **Etape 0** : Ouvrir Notepad\n-   **Etape 1** : Cliquer *Modules d'extension*<*Gestionnaires des modules d'extension*\n-   **Etape 2** : Rechercher JSON VIEWER puis cocher (Faire de même avec XML TOOLS)\n-   **Etape 3** : Cliquer sur *Installer*\n\nÀ la fin de ces étapes, vous devriez obtenir le résultat suivant :\n\n![](img/notepad_addon.png)\n\n:::\n\n## 2.4 DBEAVER\n\n::: {.justify}\n\n-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :\n    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)\n-   **Etape 1** : Télécharger l'archive ***Dbeaver.7z***\n-   **Etape 2** : Extraire l'archive téléchargée précédemment à la racine du disque *C:/*\n\nÀ la fin de ces étapes, vous devriez obtenir le résultat suivant :\n\n![](img/resultat_installation_dbeaver.png)\n\nÉgalement les sous-dossiers suivants :\n\n![](img/resultat_installation_dbeaver_subfolder.png)\n:::\n    \n## 2.5 POSTGRESQL\n\n::: {.justify}\n\nExpliquer les procédures serait un peu compliqué et redondant par rapport à la documentation qu'on peut trouver sur le web.       \nVous pouvez suivre la procédure ici :  \n[`postgresql`](https://www.postgresqltutorial.com/postgresql-getting-started/install-postgresql)                \n\n:::\n\n## 2.6 POSTMAN\n\n::: {.justify}\n\n-   **Etape 0** : Se rendre sur le site suivant :\n    -   [`postman`](https://www.postman.com/downloads/)\n-   **Etape 1** : Télécharger l'archive ***Postman-win64-Setup.exe***\n-   **Etape 2** : Double-cliquer sur l'exécutable et laissez vous guider par l'assistant d’installation\n\nÀ la fin de ces étapes, vous devriez obtenir le résultat suivant :\n\n![](img/postman.png)\n\n:::\n\n# 3. Création de traitement\n\n## 3.1\tWORKSPACE - Création d’un projet \n\n::: {.justify}\n\n::: {.callout-note}\n\n## Objectif \n\nNous allons dans cette partie créée notre premier et unique projet.        \n\n:::\n\n-   **Etape 0** : Créer un dossier : *C:/workspace_talend*\n-   **Etape 1** : Démarrer Talend\n-   **Etape 2** : Cliquer sur \"Gérer les connexions\" et choisir le dossier *C:/workspace_talend* créé en étape 0\n-   **Etape 3** : Attendre que Talend redémarre\n-   **Etape 4** : Créer un projet nommé : **OPENDATA_ASSEMBLEE_NATIONALE**\n\n::: {.callout-caution collapse=\"true\"}\n\n## Solution\n\n```{=html}\n<video \n   src=\"video/init_workspace_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n::: \n\n:::\n\n## 3.2 CSV – Traitement des données des députés\n\n### TELECHARGEMENT DU FICHIER\n\n#### CREATION DU JOB\n\n::: {.justify}\n\n::: {.callout-note}\n\n## Objectif \n\nL'objectif ici est de télécharger le fichier source que nous allons utilisé par la suite.     \n\n:::\n\n::: {.callout-tip}\n\n## Composant\n\n-   **tFileFetch** : Ce composant récupère un fichier via un protocole donné (HTTP, HTTPS, FTP ou SMB).\n\n:::\n\n-   **Etape 0** : Créer un job avec :       \n      -   pour titre : DL_DATA_DEPUTE \n      -   pour objectif : Téléchargement d’un fichier de type csv contenant les informations des députés\n      -   pour description le bloc suivant en remplaçant les {} par vos informations :        \n          -     ##########                \n                DATE DE CREATION : {dd/MM/yyyy}       \n                DATE DE MODIFICATION :         \n                VERSION : 0.1       \n                AUTEUR : {nom_prenom}       \n                DESCRIPTION  : CREATION DU JOB       \n                ##########\n\n-   **Etape 1** : Créer un dossier dans lequel nous allons mettre des fichiers brut non généré par le job qu'il prend en entrée :    \n    -   *C:/workspace_talend/source/*\n\n-   **Etape 2** : Créer un dossier dans lequel nous allons mettre des fichiers généré par le job qu'il génère en sortie :        \n    -   *C:/workspace_talend/cible/*\n\n-   **Etape 3** : Pour effectuer le téléchargement, nous allons utilisé le composant **tFileFetch** qui peut être trouvé soit dans la palette à droite, soit en tapant directement **tFileFetch** n'importe où dans le [QUADRANT NORD EST](#quad-ne).        \nSoit le paramétrage suivant :\n    -     ##########\n          URL : https://www.data.gouv.fr/fr/datasets/r/092bd7bb-1543-405b-b53c-932ebb49bb8e       \n          METHODE : GET        \n          NOM_FICHIER : depute.csv        \n          CIBLE : C:/workspace_talend/source/depute/\n          ARRET EN CAS D'ERREUR\n          ##########\n\n::: {.callout-caution collapse=\"true\"}\n\n## Solution \n\n\n```{=html}\n<video \n  src=\"video/first_job_fetch_file_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n:::\n\n:::\n\n#### EXECUTION DU JOB\n\n::: {.justify}\n\n::: {.callout-note}\n\n## Objectif \n\nL'objectif ici est de vérifier la bonne éxécution du job.       \nIci nous souhaitons simplement télécharger un fichier csv dans un dossier, il convient donc de s'assurer que ce fichier est bien présent dans le dossier spécifié.\n\n:::\n\n-   **Etape 1** : Pour pouvoir exécuter un job, il convient de se mettre dans l'onglet \"EXECUTER\" dans le [QUADRANT SUD EST](#quad-se). \n-   **Etape 2** : Cliquer EXECUTER et observer qu'aucune erreur de compilation n'est générée.   \n-   **Etape 3** : Vérifier la présence du fichier *C:/workspace_talend/source/depute/****depute.csv***.   \n      \n::: {.callout-caution collapse=\"true\"}\n\n## Solution\n\n```{=html}\n<video \n  src=\"video/launch_first_job_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n:::\n\n:::\n\n### LECTURE DU FICHIER\n\n#### CREATION DU JOB\n\n::: {.justify}\n\n::: {.callout-note}\n\n## Objectif \nNous allons dans cette partie créer un second job qui va lire le fichier télécharger par le premier. \n:::\n\n::: {.callout-tip}\n\n## Liste des composants\n\n-   **tFileInputDelimited** : Ce composant lit un fichier délimité ligne par ligne, afin de le diviser en champs et d'envoyer ces champs au composant suivant, comme défini par le schéma.\n\n:::\n\n-   **Etape 0** : Créer un job avec :        \n    -   pour titre : READ_DATA_DEPUTE \n    -   pour objectif : Lecture d'un fichier de type csv contenant les informations des députés et dans la description\n    -   pour description le bloc suivant en remplaçant les {} par vos informations :        \n        -     ##########                \n              DATE DE CREATION : {dd/MM/yyyy}       \n              DATE DE MODIFICATION :         \n              VERSION : 0.1       \n              AUTEUR : {nom_prenom}       \n              DESCRIPTION  : CREATION DU JOB       \n              ##########    \n      \n      \n-   **Etape 1** : Déterminer la structure du fichier avec Notepad.\n-   **Etape 2** : Lire le fichier *C:/workspace_talend/source/depute/****depute.csv***         \nAvec un composant **tFileInputDelimited**  que nous allons spécifier de la façon suivante:                \n     -  Le paramètrage        \n        -     ##########                \n              ENTETE : Ligne 1               \n              SEPARATION : Virgule             \n              NOM_FICHIER : depute.csv              \n              CIBLE : C:/workspace_talend/source/depute/        \n              ##########               \n     -  Le schéma \n      \n| Nom du champ | Type | Nullable | \n|---------|:-----|------:|\n| id      | STRING   |    YES |\n| legislature     | STRING  |   YES |  \n| civ       | STRING    |     YES |\n| nom       | STRING    |     YES |\n| prenom       | STRING    |     YES |\n| villeNaissance       | STRING    |     YES |\n| naissance       | STRING    |     YES |\n| age       | STRING    |     YES |\n| groupe       | STRING    |     YES |\n| groupeAbrev       | STRING    |     YES |\n| departementNom       | STRING    |     YES |\n| departementCode       | STRING    |     YES |\n| datePriseFonction       | STRING    |     YES |\n| mail       | STRING    |     YES |\n| twitter       | STRING    |     YES |\n| facebook       | STRING    |     YES |\n| website       | STRING    |     YES |\n| nombreMandats       | STRING    |     YES |\n| experienceDepute       | STRING    |     YES |\n| scoreParticipation       | STRING    |     YES |\n| scoreParticipationSpecialite       | STRING    |     YES |\n| scoreLoyaute       | STRING    |     YES |\n| scoreMajorite       | STRING    |     YES |\n| dateMaj       | STRING    |     YES |\n\n: Structure du fichier député\n\n\n::: {.callout-tip}\n\n## Type des données\n\nNous avons dans un premier temps spécifié le type `STRING` pour l'ensemble des champs afin d'être sûr de bien pouvoir lire le fichier.        \nEn effet, le type `STRING` est le plus complet dans le sens où touts les types peuvent être convertis en `STRING`        \nVoir @tbl-type.\n\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n## Solution\n\n**Etape 1**\n\n\n```{=html}\n<video \n  src=\"video/open_file_notepad_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\n**Etape 2**\n\nNous effectuons ici un paramétrage à la main.        \n\n\n```{=html}\n<video \n  src=\"video/set_schema_a_la_mano_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\n**Etape 2 : Alternative**\n\nNous effectuons ici un paramétrage via l'utilisation d'une metadonnées définit par Talend.   \n\n```{=html}\n<video \n  src=\"video/set_schema_metadata_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n:::\n\n:::\n\n#### EXECUTION DU JOB\n\n::: {.justify}\n\n::: {.callout-note}\n\n## Objectif \n\nL'objectif ici est de vérifier la bonne éxécution du job.       \nIci nous souhaitons simplement lire  un fichier csv, il convient donc de s'assurer d'imprimer dans la console leslignes lus.\n\n:::\n\n::: {.callout-tip}\n\n## Liste des composants\n\n-   **tLogRow** : Ce composant affiche les données ou les résultats dans la console de la vue Run afin de monitorer les données traitées.\n\n:::\n\n-   **Etape 0** :  Ajouter un composant **tLogRow** du côté droit du composant **tFileInputDelimited**\n-   **Etape 1** :  Cliquer droit sur le composant **tFileInputDelimited** puis choisir un lien Row puis Main et le lier au composant **tLogRow**\n-   **Etape 2** :  Exécuter le job pour observer les lignes lus par le composant **tFileInputDelimited** à travers le composant **tLogRow**\n\n::: {.callout-caution collapse=\"true\"}\n## Solution\n\n\n```{=html}\n<video \n  src=\"video/execute_read_data_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\n:::\n\n:::\n\n### ACTION SUR LA DONNEES\n\n::: {.justify}\n\nNous allons utiliser un composant **tMap** qui prend une ou plusieurs sources en entrée, permet de faire des actions sur ces données afin de définir une ou plusieurs cibles de données.  \n\nCes actions peuvent être listées :        \n\n- Transformation\n- Jointure\n- Filtre\n- Sélection\n\n:::\n\n#### TRANSFORMATION ET SELECTION\n\n::: {.justify}\n\n::: {.callout-note}\n\n## Objectif \n\nL'objectif ici est de créer un nouveau champ qui donnerait l'intitule du depute.        \nExemple : M. GOLLENTZ QUENTIN       \nNous souhaitons également sélectionner quelque champs que l'on va mettre en majuscule, renommer et trimer(=Supprimer les espaces avant et après le dernier charactère)  \n\nPlus précisément on veut créer un fichier en effectuant le mapping suivant : \n\n| Nom du source | Nom du champ cible | Fonction | \n|---------|:-----|------:|\n| depute_code     | row1.id   |    / |\n| nom_depute   | row1.nom  |   TRIM & MAJ |  \n| prenom_depute     | row1.prenom    |     TRIM & MAJ  |\n| intitule_depute       | row1.civ + \" \" + row1.nom + \" \" + row1.prenom        |     TRIM & MAJ  |\n| groupe_politique       | row1.groupeAbrev     |     TRIM & MAJ  |\n:::\n\n::: {.callout-tip}\n\n## Liste des composants et fonctions\n\n-   **tFileInputDelimited** : Ce composant lit un fichier délimité ligne par ligne, afin de le diviser en champs et d'envoyer ces champs au composant suivant, comme défini par le schéma.      \n-   **tMap** : Ce composant transforme et route des données à partir d'une ou plusieurs source(s) de données vers une ou plusieurs destination(s).        \n-   **tFileOutputDelimited** : Ce composant écrit en sortie les données d'entrée dans un fichier délimité en respectant le schéma défini.\n\n-   *MAJ* : StringHandling.UPCASE()\n-   *TRIM* : StringHandling.TRIM()\n\n\n:::\n\n-   **Etape 0** : Créer un job avec :       \n      -   pour titre : TRANSFORM_DATA_DEPUTE \n      -   pour objectif : Transformation du fichier deputes.csv\n      -   pour description le bloc suivant en remplaçant les {} par vos informations :        \n          -     ##########                \n                DATE DE CREATION : {dd/MM/yyyy}       \n                DATE DE MODIFICATION :         \n                VERSION : 0.1       \n                AUTEUR : {nom_prenom}       \n                DESCRIPTION  : CREATION DU JOB       \n                ##########\n-   **Etape 2** : Lire le fichier *C:/workspace_talend/source/depute/****depute.csv*** de la même manière que dans le job READ_DATA_DEPUTE\n\n::: {.callout-tip}\n## Interet de la metada\n\nOn voit ici l'avantage de spécifié des metada.        \nSi vous avez spécifié la metadata FICHIER_DEPUTE alors vous pouvez directement l'importer sans avoir à refaire le le paramétrage.              \nSi non vous pouvez toujours copier le **tFileInputDelimited** du job READ_DATA_DEPUTE et le coller dans le nouveau job TRANSFORM_DATA_DEPUTE\n:::\n\n-   **Etape 3** :  Ajouter un composant **tMap** du côté droit du composant **tFileInputDelimited**\n-   **Etape 4** :  Cliquer droit sur le composant **tFileInputDelimited** puis choisir un lien Row puis Main et le lier au composant **tMap**\n-   **Etape 5** :  Dans le **tMap** créer une sortie `depute_transform` avec le mapping suivant :    \n\n| Nom du source |Type source |  Nom du champ cible | Type cible | Fonction |        \n|---------|:-----|:-----|------:|        \n| depute_code     |STRING| row1.id   |STRING|    / |        \n| nom_depute   |STRING| row1.nom  |STRING|   TRIM & MAJ |  \n| prenom_depute     |STRING| row1.prenom    |STRING|     TRIM & MAJ  |\n| intitule_depute       |STRING| row1.civ + \" \" + row1.nom + \" \" + row1.prenom        |STRING|     TRIM & MAJ  |\n| groupe_politique       |STRING| row1.groupeAbrev     |STRING|     TRIM & MAJ  |\n\n-   **Etape 6** :  Ajouter un composant **tFileOutputDelimited** du côté droit du composant **tMap** \n-   **Etape 7** :  Cliquer droit sur le composant **tMap** puis choisir un lien Row puis `depute_transform` et le lier au composant **tFileOutputDelimited**\n-   **Etape 8** :  Paramètrer le composant **tFileOutputDelimited** de la façon suivante :        \n    -       ##########\n            ENTETE : depute_code;nom_depute;prenom_depute;intitule_depute;groupe_politique      \n            SEPARATION : Point-Virgule      \n            NOM_FICHIER : depute_collaborateur.csv        \n            CIBLE : C:/workspace_talend/cible/depute/\n            NE PAS RETOURNER D'ERREUR SI LE FICHIER EXISTSE\n            ENCODAGE : UTF-8\n            CREER LE REPERTOIRE SI IL N'EXISTE PAS\n            ########## \n\n::: {.callout-caution collapse=\"true\"}\n## Solution\n\n```{=html}\n<video \n  src=\"video/transform_data_tmap_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n:::\n\n:::\n\n#### JOINTURE\n\n::: {.justify}\n\n::: {.callout-note}\n\n## Objectif \n\nNous souhaitons avoir un fichier des collaborateurs des députés.        \nPour cela nous allons réaliser une jointure entre le fichier des deputes et un fichier des collaborateurs.\n\n:::\n\n-   **Etape 0** : Mettre à jour le job DL_DATA_DEPUTE en spécifiant une mineur 0.2 et ajoutant à la description le bloc suivant :       \n      -     ##########                        \n            DATE DE CREATION : {date_creation_1}             \n            DATE DE MODIFICATION : {dd/MM/yyyy}               \n            VERSION : 0.2              \n            AUTEUR : {nom_prenom}              \n            DESCRIPTION  : TELECHARGEMENT D'UN FICHIER SUPLLEMENTAIRE            \n            ##########        \n            DATE DE CREATION : {date_creation_1}              \n            DATE DE MODIFICATION :                \n            VERSION : 0.1           \n            AUTEUR : {nom_prenom}               \n            DESCRIPTION  : CREATION DU JOB            \n            ##########\n    \n::: {.callout-tip}\n## Utilité des descriptions\n\nCes divers bloc sont là pour tracer les diverses évolutions que peut rencontrer un flux.    \n:::\n\n- **Etape 2** : Dupliquer le composant **tFileFetch** avec pour paramétrage :        \n    -     ##########                \n          URL : https://data.assemblee-nationale.fr/static/openData/repository/16/amo/collaborateurs_csv_opendata/liste_collaborateurs_excel.csv\n          METHODE : GET \n          NOM_FICHIER : collaborateur.csv\n          CIBLE : C:/workspace_talend/source/depute/\n          ##########\n\n- **Etape 3** : Lier l'éxécution du composant nouvellement créé avec l'ancien, en cliquant droit sur le premier composant, puis choisir *On Component Ok* pour cliquer gauche sur le nouveau compissant\n- **Etape 4** : Renommer les composants :\n  \n    - **tFileFetch_1** en DL_DEPUTE\n    - **tFileFetch_2** en DL_COLLAB\n- **Etape 5** : Executer le job et s'assurer de la bonne présence du fichier **collaborateur.csv** dans le dossier **C:/workspace_talend/source/depute/**\n\n\n::: {.callout-caution collapse=\"true\"}\n## Solution\n\n```{=html}\n<video \n  src=\"video/modification_job_dl_log_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n```{=html}\n<video \n  src=\"video/dl_collab_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\n\n![](img/realisation_dl_collab.png)\n\n:::\n\n:::\n\n#### Etape 2 : Modification READ_DATA_DEPUTE\n\n::: {.justify}\n\nIl convient de mettre à jour le job READ_DATA_DEPUTE en spécifiant une mineur 0.2 et ajoutant à la description le bloc suivant :           \n\n-     ##########                \n      DATE DE CREATION : REPRENDRE LA DATE DE CREATION DU BLOC PRECEDENT      \n      DATE DE MODIFICATION : {dd/MM/yyyy}        \n      VERSION : 0.2       \n      AUTEUR : {nom_prenom}       \n      DESCRIPTION  : JOINTURE AVEC LES COLLABARATEUR     \n      ########## \n\n\nCes divers bloc sont là pour tracer les diverses évolutions que peut rencontrer un flux.        \n\nLa première chose à faire est de déterminer la structure du fichier.         \nPour cela nous allons l’ouvrir avec Notepad :\n\n\n```{=html}\n<video \n  src=\"video/open_file_notepad_bis_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\nNous constatons le paramétrage:\n\n-     ##########\n      ENTETE : Ligne 1       \n      SEPARATION : Point-Virgule      \n      NOM_FICHIER : colaborateur.csv        \n      CIBLE : C:/workspace_talend/source/depute/\n      ##########\n\nAvec le schéma suivant : \n\n| Nom du champ | Type | Nullable | \n|---------|:-----|------:|\n| id (Identifiant du député)      | STRING   |    YES |\n| nom_depute   | STRING  |   YES |  \n| prenom_depute     | STRING    |     YES |\n| nom_collab       | STRING    |     YES |\n| prenom_collab       | STRING    |     YES |\n\n\n: Structure du fichier\n\nLa première ligne est l'identifiant du **députés** qui va nous permettre de faire la jointure entre les deux fichiers.\nLe `prénom` et le `nom` du **députés** sont déjà présent dans le fichier ***deputes.csv**, ainsi seul les informations du collaborateur vont être utile.\n\nMaintenant il convient d'apporter la modification suivante :      \n\n- Lire le nouveau fichier avec le schéma \n- Faire la jointure dans le **tMap**\n- Ajouter les champs liées au collaborateur en sortie et plus précisément un champ `collab` qui va prendre le nom et prénom du collaborateur :       \n  - Soit `row2` la sorie du composant **tFileInputDelimited** lié au fichier ***collaborateur.csv***         \n    Nous avons alors `collab = row2.nom_collab + \" \" + row2.prenom_collab` \n- Renommer les composants Talend\n\n\n```{=html}\n<video \n  src=\"video/tentative_jointure_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\nDans ce premier jet, la jointure n'a ramené aucune ligne parce que les valeurs des champs dans ***collaborateur.csv*** sont entourés par des double quote.                        \nIl convient donc de les supprimer afin que l'on est le même format entre l'`id` du député du fichier **deputes.csv** et l'`id` du député du fichier **collaborateur.csv**\n\n\n```{=html}\n<video \n  src=\"video/jointure_collab_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\nDans cette version, nous avons en entrée 578 députés et en sortie 577 ligne de couple député/collaborateur.\n\nCela n'est pas le résultat voulu, en effet un députés à au moins un collaborateur et souvent plus d'un.       \nNéanmoins ce résultat est le signe d'une ligne d'un députés sans collaborateur\n\nNous allons donc récupérer l'ensemble des correspondance que l'on va écrire dans un fichier ***depute_collaborateur.csv*** et récupérer les collaborateur sans députés dans un fichier de ***rejet rejet_collaborateur.csv***.\n\n- ***depute_collaborateur.csv*** :        \n  -       ##########\n          ENTETE : intitule;collaborateur      \n          SEPARATION : Point-Virgule      \n          NOM_FICHIER : depute_collaborateur.csv        \n          CIBLE : C:/workspace_talend/cible/depute/ \n          ##########   \n\n- ***rejet_collaborateur.csv*** :        \n  -       ##########\n          ENTETE : intitule;collaborateur      \n          SEPARATION : Point-Virgule      \n          NOM_FICHIER : rejet_collaborateur.csv        \n          CIBLE : C:/workspace_talend/cible/depute/rejet\n          ##########    \n\n    \n\n```{=html}\n<video \n  src=\"video/jointure_collab_final_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\nIl semblerait que la ligne en rejet ne possède aucune information.        \nIl va falloir investiguer plus en détails le fichier des députés.       \n    \nNous pouvons observer un problème à la ligne 481 qui est en fait le fin de la ligne 480.        \nIl faudrait mettre un processus de nettoyage de la données, cependant par économie de temps, nous allons considérer la correction manuelle suivante :       \n\n\n```{=html}\n<video \n  src=\"video/problème_ligne_81_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\n:::\n\n#### Etape 3 : Création d'un fichier par groupe politique\n\n::: {.justify}\n\nDans cette partie, nous allons utiliser le concept de variables globales ainsi que le principe d'itération.       \n\nNous allons lire le fichier ***deputes.csv*** une première fois avec un composant **tFileInputDelimited** puis récupérer une ligne par groupe politique distinct grâce à un composant **tUniqRow** en utilisant le champ `groupeAbrev` pour ensuite la stocker dans une variable global `groupe` grâce à un composant **tFlowToItererate** dont la valeur peut être récupéré en faisant appel dans du code Java avec `(String)globalMap.get(\"groupe\")`.        \n\nA chaque itération, nous allons relire le fichier députes cependant pour ne pas perdre l'itération nous devons préalablement connecter ce nouveau **tFileInputDelimited** à un composant **tJava** en mode *on Component OK*   lui-même lié au composant **tFlowToItererate** en mode *Iterate* .       \nNous réaliserons la jointure mais également l'application d'un filtre en sortie de tel manière à ce qu'on ne considère que le groupe politique en question avec  `row1.groupeAbrev.equals((String)globalMap.get(\"groupe\"))` dans un **tMap** afin de construire les fichiers :       \n\n-   ***depute_collaborateur_ +  (String)globalMap.get(\"groupe\") + \".csv*** :        \n    -     ##########                \n          ENTETE : intitule;collab      \n          SEPARATION : Point-Virgule      \n          NOM_FICHIER : depute_collaborateur_ +  (String)globalMap.get(\"groupe\") + \".csv        \n          CIBLE : C:/workspace_talend/cible/depute/      \n          ##########\n \n-   ***rejet_collaborateur_ +  (String)globalMap.get(\"groupe\") + \".csv*** :       \n    -     ##########\n          ENTETE : nom_depute;prenom_depute;nom_collaborateur;prenom_collaborateur      \n          SEPARATION : Point-Virgule      \n          NOM_FICHIER : rejet_collaborateur_ +  (String)globalMap.get(\"groupe\") + \".csv        \n          CIBLE : C:/workspace_talend/cible/depute/rejet \n          ########## \n\n\n```{=html}\n<video \n  src=\"video/collab_jointure_par_groupe_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n:::\n\n## 3.3\tJSON – Traitement des données de votes\n\n### TELECHARGEMENT DU FICHIER\n\n::: {.justify}\n\nL’objectif ici est de télécharger le fichier source que nous allons utilisé par la suite.       \nNous allons créer un job avec :       \n\n-   pour titre : DL_DATA_VOTE       \n-   pour objectif : Téléchargement d’un fichier de type json  contenant les informations de vote        \n-   pour description le bloc suivant en remplaçant les {} par vos informations :    \n    -     ##########                \n          DATE DE CREATION : {dd/MM/yyyy}       \n          DATE DE MODIFICATION :         \n          VERSION : 0.1       \n          AUTEUR : {nom_prenom}       \n          DESCRIPTION  : CREATION DU JOB     \n          ##########\n\n\nPour effectuer le téléchargement, nous allons utilisé le composant **tFileFetch** qui peut être trouvé soit dans la palette à droite, soit en tapant directement **tFileFetch** n’importe où dans le quadrant nord-est.\n\nSoit le paramétrage suivant :\n\n-       ##########\n        URL : \"http://data.assemblee-nationale.fr/static/openData/repository/16/loi/scrutins/Scrutins.json.zip\"       \n        METHODE : GET        \n        NOM_FICHIER : \"vote.zip\"        \n        CIBLE : \"C:/workspace_talend/source/vote/\" \n        ARRET EN CAS D'ERREUR\n        ##########\n\nNous devons maintenant extraire l'archive, pour cela nous pouvons utiliser un composant **tFileUnarchive** avec pour paramétrage suivant :  \n\n-       ##########                \n        FICHIER D'ARCHIVE : C:/workspace_talend/source/vote/vote.zip       \n        REPERTOIRE D'EXTRACTION  : C:/workspace_talend/source/vote/      \n        ##########\n        \n        \n- Lier l'éxécution du composant nouvellement créé avec l'ancien, en cliquant droit sur le premier composant, puis choisir *On Component Ok*\n\nA la fin vous devriez avoir une liste de fichier JSON dans le dossier :       \n*C:/workspace_talend/source/vote/json*\n\n\n```{=html}\n<video \n  src=\"video/get_json_data_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\n:::\n\n### LECTURE DU FICHIER\n\n::: {.justify}\n\nNous allons dans cette partie créer un second job qui va lire le fichier télécharger par le premier.        \nNous allons créer un job avec :       \n\n-   pour titre : READ_DATA_VOTE \n-   pour objectif : Lecture d'un fichier de type json contenant les informations des députés et dans la description\n-   pour description le bloc suivant en remplaçant les {} par vos informations :        \n    -     ##########                \n          DATE DE CREATION : {dd/MM/yyyy}       \n          DATE DE MODIFICATION :         \n          VERSION : 0.1       \n          AUTEUR : {nom_prenom}       \n          DESCRIPTION  : CREATION DU JOB       \n          ##########\n\nLa première chose à faire est de déterminer la structure du fichier ou plutôt d'un fichier quelconque.\nNous souhaitons récupérer :  \n\n- L'ensemble des votes POUR dont les identifiants de ces votants sont présent dans l’élément `acteurRef` dans le noeud :          \n    -   scrutin/ventilationVotes/organe/groupes/groupe/vote/decompteNominatif/**pours**/votant/\n- L'ensemble des votes CONTRE dont les identifiants de ces votants sont présent dans l’élément `acteurRef` dans le noeud :       \n    - scrutin/ventilationVotes/organe/groupes/groupe/vote/decompteNominatif/**contres**/votant/\n\nNous allons malheureusement définir deux metada pour le même fichier, en effet Talend ne gère qu'une boucle, or nous avons besoin de boucler sur les POUR, mais également les CONTRES.\n\n\n```{=html}\n<video \n  src=\"video/read_data_json_opt.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\nNous allons donc lire le même fichier avec un composant **tFileInputJSON** mais selon deux metadata différentes pour ensuite ajouter via un composant **tJavaRow** un champ `vote_code` avec pour valeur :        \n\n-   1 si le députés est dans le noeud **POUR**\n-   0 si le députés est dans le noeud **CONTRE**.\n\nNous allons ensuite réunir les deux jeux de données dans un composant **tUnite** avant d'écrire un fichier unique\n\n- ***vote.csv*** :                \n\n  -     ##########\n        ENTETE : Ligne 1       \n        SEPARATION : Point-Virgule      \n        NOM_FICHIER : vote.csv     \n        CIBLE : C:/workspace_talend/cible/vote/\n        ##########\n\n\n```{=html}\n<video \n  src=\"video/read_data_vote_opt_final.mp4\" \n  width=\"1000\" \n  height=\"500\">\n</video>\n```\n\n\n:::\n\n### CREATION D'UN FICHIER GLOBAL DE VOTE\n\n::: {.justify}\n\nLe problème avec le flux précédent est que nous avons uniquement fait un traitement pour un fichier de la liste.        \nAinsi il va falloir pour chaque fichier de la liste faire cette action.\n\n- Lister les fichier du répertoire *C:/workspace_talend/source/vote/json* avec un composant **tFileList** avec pour recherche le pattern `*.json`\n- Lier ce composant avec un composant **tJava** en mode *Iterate*\n- Lier le composant **tJava** au sous-job précédemment développer avec un lien *On Component OK*\n- Mettre à jour les composants **tFileInputJSON** en modifiant le fichier à lire par la variable globale `((String)globalMap.get(\"tFileList_1_CURRENT_FILEPATH\"))`issus du composant **tFileList**\n- Ajouter un champ `loi_code` avec pour valeur `((String)globalMap.get(\"tFileList_1_CURRENT_FILE\"))` issus du composant **tFileList** \n- Mettre à jour le schéma des composant **tUnite** et **tFileOutputDelimited** afin de considérer le nouveau champ `loi_code`\n- Mettre à jour le composant **tFileOutputDelimited** afin d'écrire les données à la suite du fichier existant\n\n:::\n\n## 3.4\tPOSTGRESQL – Alimentation de la base de données\n\n::: {.justify}\n\nNous allons dans la suite créer un job ALIM_BDD_OPENDATA_ASSEMBLEE_NATIONALE en nous inspirant des jobs :       \n\n-   READ_DATA_DEPUTE        \n-   READ_DATA_VOTE\n\nL'idée est de remplacer la cible qui à la place d'être des fichiers vont être des tables.       \nNous souhaitons obtenir le MPD suivant :                \n\n```{mermaid}\nerDiagram\n    COLLAB ||--|{ DEPUTE : rattachement \n    COLLAB {\n        integer collab_code PK \"sequence incremental pour chaque depute_code\"\n        string depute_code PK \"id du fichier collaborateur\" \n        string nom_collab  \"nom_collab du fichier collaborateur avec MAJUSCULE & TRIM\" \n        string prenom_collab  \"prenom_collab du fichier collaborateur avec MAJUSCULE & TRIM\"\n        string intitule_collab \"nom_collab + prenom_collab du fichier collaborateur avec MAJUSCULE & TRIM\"\n    }\n    DEPUTE }o--|{ VOTE : vote\n    DEPUTE {\n       string depute_code PK \"id du fichier deputes\"\n       string nom_depute  \"nom du fichier depute avec MAJUSCULE & TRIM\"\n       string prenom_depute  \"prenom du depute collaborateur avec MAJUSCULE & TRIM\"\n       string intitule_depute  \"prenom du fichier depute avec MAJUSCULE & TRIM\"\n       string groupe_politique  \"prenom du fichier depute avec MAJUSCULE & TRIM\"\n\n    }\n    VOTE {\n      string depute_code PK \"champ depute_code des fichiers de *.json\"\n      string loi_code PK \"nom du fichier du fichier de vote\"\n      integer vote_code \"champ construit dans le job READ_DATA_VOTE\"\n  }\n```\n\n:::\n\n### CREATION DE LA BDD\n\n::: {.justify}\n\nAvant de créer les tables, il convient de créer une base de données ainsi qu'un schéma dans lesquels nous allons construire nos différentes tables.       \nPour cela, il convient d'ouvrir PgAdmin, puis de construire une database avec pour nom `OPENDATA_ASSEMBLEE_NATIONALE` et un schema avec pour nom `dwh` :\n\nCela peut être réalisé via les commandes suivantes :\n```SQL\nDROP DATABASE IF EXISTS \"OPENDATA_ASSEMBLEE_NATIONALE\";\n\nCREATE DATABASE \"OPENDATA_ASSEMBLEE_NATIONALE\"\n    WITH \n    OWNER = postgres\n    ENCODING = 'UTF8'\n    LC_COLLATE = 'French_France.1252'\n    LC_CTYPE = 'French_France.1252'\n    TABLESPACE = pg_default\n    CONNECTION LIMIT = -1;\n\nCOMMENT ON DATABASE \"OPENDATA_ASSEMBLEE_NATIONALE\"\n    IS 'Base de données contenant les informations issus de l'OpenData de l'Assemblée Nationale';\n    \nDROP SCHEMA IF EXISTS dwh ;\n\nCREATE SCHEMA IF NOT EXISTS dwh\n    AUTHORIZATION postgres;\n```\n\nMaitenant que nous avons une BDD ainsi qu'un schéma, nous pouvons créer les différentes tables :   \n\n- Table DEPUTE :        \n```SQL\nCREATE TABLE dwh.\"DEPUTE\" (\n\tdepute_code varchar(20) NOT NULL,\n\tnom_depute varchar(250) NULL,\n\tprenom_depute varchar(250) NULL,\n\tintitule_depute varchar(250) NULL,\n\tgroupe_politique varchar(250) NULL\n\n);\n``` \n\n- Table COLLAB :        \n```SQL\nCREATE TABLE dwh.\"COLLAB\" (\n  collab_code integer NOT NULL,\n  depute_code varchar(20) NOT NULL,\n  nom_collab varchar(250) NULL,\n  prenom_collab varchar(250) NULL,\n  intitule_collab varchar(250) NULL\n);\n```\n\n- Table VOTE :        \n```SQL\nCREATE TABLE dwh.\"VOTE\" (\n\tdepute_code varchar(20) NOT NULL,\n\tloi_code varchar(250) NOT NULL,\n\tvote_code  integer NOT NULL\n);\n```\n\n:::\n\n### ALIMENTATION DE LA BDD\n\n::: {.justify}\n\nNous allons créer un job avec :       \n\n-   pour titre : ALIM_BDD_OPENDATA_ASSEMBLEE_NATIONALE \n-   pour objectif : Alimentation de la BDD OPENDATA_ASSEMBLEE_NATIONALE \n-   pour description le bloc suivant en remplaçant les {} par vos informations :        \n    -     ##########                \n          DATE DE CREATION : {dd/MM/yyyy}       \n          DATE DE MODIFICATION :         \n          VERSION : 0.1       \n          AUTEUR : {nom_prenom}       \n          DESCRIPTION  : CREATION DU JOB       \n          ##########\n          \n#### Nous réaliserons les étapes suivantes pour l'alimentation de la table VOTE:       \n\n- Paramétrer la connexion à la BDD avec un composant **tPostrgreSQLConnection** avec pour paramétrage :        \n  -     ##########\n        HOST : localhost      \n        BDD : OPENDATA_ASSEMBLEE_NATIONALE      \n        PORT : 5432   \n        SCHEMA : dwh\n        PARAMETRES AVANCE : COMMIT AUTOMATIQUE\n        ##########\n- Copier l'ensemble du l'ensemble du job READ_DATA_VOTE qu'on lit au composant **tPostrgreSQLConnection** avec un lien *On Component OK*\n- Changer la cible **tFileOutputDelimited** par un composant **tPostrgreSQLOutput** avec pour paramètrage :        \n  -     ##########\n        UTILISER LA CONNEXION\n        TABLE : VOTE\n        ACTION SUR LA TABLE : DEFAUT\n        ACTION SUR LES DONNES : INSERT OU UPDATE\n        ##########\n        \nAvec le schéma suivant : \n\n| Nom du champ | Type | Nullable | KEY\n|---------|:-----|:-----|------:|\n| depute_code      | STRING   |    NO |YES |\n| loi_code   | STRING  |   NO |  YES |\n| vote_code     | INTEGER    |     NO |NO |\n\n:::\n\n####  Nous réaliserons les étapes suivantes pour l'alimentation de la table DEPUTE et de la table COLLAB:     \n\n::: {.justify}\n\n-   Copier et coller le sous-job du job READ_DATA_DEPUTE lié à la jointure et à l'alimentation des fichiers **deputes.csv**\n-   Lier le sous-job d'alimentation de la table VOTE à ce nouveau job\n-   Changer le **tMap** afin de réaliser le  mapping suivant :           \n\n| Nom du source | Nom du champ cible | Fonction | \n|---------|:-----|------:|\n| depute_code     | row1.id   |    / |\n| nom_depute   | row1.nom  |   TRIM & MAJ |  \n| prenom_depute     | row1.prenom    |     TRIM & MAJ  |\n| intitule_depute       | row1.civ + \" \" + row1.nom + \" \" + row1.prenom        |     TRIM & MAJ  |\n| groupe_politique       | row1.groupeAbrev     |     TRIM & MAJ  |\n\n: Mapping DEPUTE\n\n- Ajouter un composant **tUniqRow** en sortie DEPUTE du **tMap** avec pour identifiant unique l'attribut `depute_code`        \n- Mettre en sortie un composant **tPostrgreSQLOutput** pour la sortie DEPUTE avec pour paramètrage :        \n  -     ##########\n        UTILISER LA CONNEXION\n        TABLE : DEPUTE\n        ACTION SUR LA TABLE : SUPPRIMER SI ELLE EXISTE ET LA CREER\n        ACTION SUR LES DONNES : INSERT\n        ##########\n\nAvec le schéma suivant : \n\n| Nom du champ | Type | Nullable | KEY\n|---------|:-----|:-----|------:|\n| depute_code     | STRING   |    NO |\n| nom_depute   | STRING  |   YES |  \n| prenom_depute     | STRING    |     YES  |\n| intitule_depute       | STRING        |    YES  |\n| groupe_politique       | STRING    |    YES  |\n\n-   Changer le **tMap** afin de réaliser le  mapping suivant :           \n\n\n| Nom du source | Nom du champ cible | Fonction | \n|---------|:-----|------:|\n| collab_code     | row1.id   |     Numeric.sequence() |\n| depute_code     | row1.id   |    / |\n| nom_collab   | row2.nom_collab  |   TRIM & MAJ |  \n| prenom_collab     | row2.prenom_collab    |     TRIM & MAJ  |\n| intitule_collab      | row2.nom_collab + \" \" + row2.prenom_collab        |     TRIM & MAJ  |\n\n\n: Mapping COLLAB\n\n- Mettre en sortie un composant **tPostrgreSQLOutput** pour la sortie COLLAB avec pour paramètrage :        \n  -     ##########\n        UTILISER LA CONNEXION\n        TABLE : COLLAB\n        ACTION SUR LA TABLE : SUPPRIMER SI ELLE EXISTE ET LA CREER\n        ACTION SUR LES DONNES : INSERT\n        ##########\n\nAvec le schéma suivant : \n\n| Nom du champ | Type | Nullable | KEY\n|---------|:-----|:-----|------:|\n| collab_code     | STRING   |    NO |\n| depute_code     | STRING   |    NO |\n| nom_collab   | STRING  |   YES |  \n| prenom_collab       | STRING    |     YES  |\n| intitule_collab         | STRING        |    YES  |\n\n:::\n\n### RECETTE DE LA BDD\n\n::: {.justify}\n\nDans cette partie, nous allons nous assurer que le job fonctionne bien.       \nPour cela nous allons utiliser DBeaver.        \n\n:::{.callout-note}\nNous aurions pus nous contenter de PgAdmin cependant cette outils ne permet d'interagir qu'avec des base de données de type PostgreSQL, là où DBeaver permet d'interagir avec un grand nombre d'autre type.\n:::\n\n- Ouvrir Dbeaver\n- Créer un dossier OPENDATA_ASSEMBLEE\n- Créer une connexion PostgreSQL à la BDD OPENDATA_ASSEMBLEE_NATIONALE\n- Double-cliquer sur les tables afin de visualiser les données\n\n![](img/dbeaver_table.png)\n:::\n\n## 3.5\tREST – Récupération des informations liés à un députés\n\n::: {.justify}\n\n[Source : @INSATUNISIA](https://insatunisia.github.io/TP-eServices/tp1/)\n\n:::\n\n### CREATION D'UNE REQUETE\n\n::: {.justify}\n:::\n\n### CREATION D'UNE API\n\n::: {.justify}\n\nNous allons maintenant créer le service REST. Pour cela, créer un nouveau job, qu'on appellera *GETINFO_OPENDATA_ASSEMBLEE_NATIONALE*, puis glisser les composants suivants:\n\n* **tPostgreSQLConnection** : Pour définir la connexion à la BDD OPENDATA_ASSEMBLEE_NATIONALE\n* **tRestRequest** : Pour définir la requête REST que le client doit appeler\n* **tPostgreSQLInput** : Table de la base de données\n\n:::{.callout-note}\nJe choisis ***tPostgreSQLInput*** car, dans mon cas, c'est une base de données PostgreSQL, et je veux juste lire son contenu, je vais donc y accéder en entrée (d'où le ***Input***).\n:::\n\n* **tFlowToIterate** : Pour effectuer une itération sur les données d'entrée et génèrer des variables globales.\n* **tXMLMap** : Permet de router et transformer les flux entrants de la base de données vers le résultat de la requête.\n* **tRestResponse** : Pour définir la réponse à envoyer à l'utilisateur suite à sa requête.\n* **tLogRow** : Pour le log, bien sûr.\n\nLe job aura l'allure suivante:\n\n![Service REST](img/rest-service.png)\n\nNous désirons configurer le service de manière à ce que, quand un consommateur appelle l'URI `http://localhost:8088/depute?depute_code=param` avec pour `param`, un identifiant de `depute`, le service retourne une réponse contenant les informations du député dont une liste des collaborateur.\n\n#### Configuration de tRestRequest\ntRestRequest devra être configuré comme suit:\n\n* La valeur de *Endpoint URL* devra être: `\"http://localhost:8088/depute\"`\n* Si vous avez connecté le tRestRequest avec le tFlowToIterate avec un lien appelé *getDepute*, vous devriez le retrouver dans la case *REST API Mapping*. Sinon, créez-le.\n* Garder les informations par défaut de ce mapping (méthode GET, URI /, Produit XML ou JSON).\n* En cliquant sur *getDepute*, un bouton avec trois petits points apparaît. Cliquez dessus.\n* Ajouter les deux colonnes *depute_code* représentant le  paramètre de la requête. Prenez soin à ce que:\n\n    * Son type soit *string*\n    * La valeur par défaut soit de PA722142 .\n    * Leur commentaire ait la valeur: *query*\n\n\n:::{.callout-note}\nLa valeur par défaut est utilisée dans le cas où le consommateur n'introduit pas de paramètres.\n:::\n\n\n:::{.callout-note}\nLe commentaire query indique que ce champ est un paramètre de requête, pas définie dans le Path.\n:::\n\n:::\n\n#### Configuration de depute\n\n::: {.justify}\n\nPuisque le composant *depute* a été créé à partir de la connexion à votre base PostgreSQL, il contient déjà les informations de connexion nécessaires.\n\nIl suffira dans notre cas de:\n\n* Cliquer sur *Guess Schema*  pour charger le schéma de la base.\n* Changer la requête pour qu'elle soit comme suit:\n\n```sql\nSELECT \n\n  D.depute_code,\n  D.nom_depute,\n  D.prenom_depute,\n  D.intitule_depute ,\n  D.groupe_politique,\n  C.collab_code,\n  C.nom_collab,\n  C.prenom_collab,\n  C.intitule_collab,\n  V.loi_code,\n  V.vote_code\n  \nFROM \"DEPUTE\" D\n\nINNER JOIN \"COLLAB\" C\nON D.depute_code = C.depute_code\n\nWHERE D.depute_code IN (\"+ globalMap.get(\"getDepute.depute_code\") + \")\n```\n\n:::{.callout-note}\n globalMap est une variable globale permettant de stocker les informations de la requête, comme par exemple ses paramètres.\n:::\n\n:::\n\n#### Configuration de tXMLMap\n\n::: {.justify}\n\nCliquer deux fois sur la *tXMLMap* pour la configurer.\n\n* Dans la colonne de droite, ajouter (si ce n'est déjà fait) une colonne intitulée *body* dont le type est *Document*.\n* Cette colonne contient un élément *root*. Renommer cet élément pour *députés*.\n* Ajouter un sous-élément à *deputes* appelé *depute*\n* Glisser-déplacer le depute_code de la colonne en entrée vers le *depute*. Créez-le comme attribut du noeud cible.\n* De même pour le *prenom_depute*,*prenom_depute*,*groupe_politique*,*intitule_depute*, qui seront, eux, des sous-éléments du noeud *depute*.\n* Ajouter un sous-élément à *collaborateurs* appelé *collaborateur*.\n* Définir cet élément comme *loop Element*.\n* Glisser-déplacer le collab_code de la colonne en entrée vers le *collaborateur*. Créez-le comme attribut du noeud cible.\n* De même pour le *prenom_collab*,*prenom_collab*,*intitule_collab*, qui seront, eux, des sous-éléments du noeud *collaborateur*.\n* Dans la colonne de droite, cliquer sur la petite clef à molette (![](img/clef-molette.png)). Mettre la valeur de \"All in one\" à *true*. Cela permettra à toutes les données XML d'être écrites dans un seul flux.\n\nLa configuration finale sera donc comme suit:\n\n![tXMLMap du Service REST](img/rest-txmlmap.png)\n\n:::{.callout-note}\nLa configuration précédente va générer une réponse de la forme suivante:\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<deputes>\n    <depute depute_code=\"PA795596\">\n        <nom_depute>VANNIER</nom_depute>\n        <prenom_depute>PAUL</prenom_depute>\n        <intitule_depute>M. VANNIER PAUL</intitule_depute>\n        <groupe_politique>LFI-NUPES</groupe_politique>\n        <collaborateurs>\n            <collaborateur collab_code=\"1\">\n                <nom_collab>MARZOUGUI</nom_collab>\n                <prenom_collab>ANIS</prenom_collab>\n                <intitule_collab>MARZOUGUI ANIS</intitule_collab>\n            </collaborateur>\n            <collaborateur collab_code=\"2\">\n                <nom_collab>FOUCAULT</nom_collab>\n                <prenom_collab>CLÉMENCE</prenom_collab>\n                <intitule_collab>FOUCAULT CLÉMENCE</intitule_collab>\n            </collaborateur>\n            <collaborateur collab_code=\"3\">\n                <nom_collab>AWAD ABDOU</nom_collab>\n                <prenom_collab>MOHAMED</prenom_collab>\n                <intitule_collab>AWAD ABDOU MOHAMED</intitule_collab>\n            </collaborateur>\n        </collaborateurs>\n    </depute>\n</deputes>\n```\n:::\n\nLes autres composants devront rester tels qu'ils sont par défaut. Il suffira maintenant de lancer le service, en cliquant sur *Exécuter*.\n\n:::\n\n### CONSOMMATEUR DU WEBSERVICE\n\n::: {.justify}\n\nPour tester le service, il suffit d'ouvrir un navigateur, et de taper la requête de votre choix.\n\nPar exemple, la requête suivante : `http://localhost:8088/depute?depute_code=PA795596` donnera:\n\n```XML\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<deputes>\n    <depute depute_code=\"PA795596\">\n        <nom_depute>VANNIER</nom_depute>\n        <prenom_depute>PAUL</prenom_depute>\n        <intitule_depute>M. VANNIER PAUL</intitule_depute>\n        <groupe_politique>LFI-NUPES</groupe_politique>\n        <collaborateurs>\n            <collaborateur collab_code=\"1\">\n                <nom_collab>MARZOUGUI</nom_collab>\n                <prenom_collab>ANIS</prenom_collab>\n                <intitule_collab>MARZOUGUI ANIS</intitule_collab>\n            </collaborateur>\n            <collaborateur collab_code=\"2\">\n                <nom_collab>FOUCAULT</nom_collab>\n                <prenom_collab>CLÉMENCE</prenom_collab>\n                <intitule_collab>FOUCAULT CLÉMENCE</intitule_collab>\n            </collaborateur>\n            <collaborateur collab_code=\"3\">\n                <nom_collab>AWAD ABDOU</nom_collab>\n                <prenom_collab>MOHAMED</prenom_collab>\n                <intitule_collab>AWAD ABDOU MOHAMED</intitule_collab>\n            </collaborateur>\n        </collaborateurs>\n    </depute>\n</deputes>\n```\nSi aucun paramètre n'est indiqué: `http://localhost:8088/depute` cela donnera:\n\n```XML\n<depute depute_code=\"PA722142\">\n\t<nom_depute>RUFFIN</nom_depute>\n\t<prenom_depute>FRANÇOIS</prenom_depute>\n\t<intitule_depute>M. RUFFIN FRANÇOIS</intitule_depute>\n\t<groupe_politique>LFI-NUPES</groupe_politique>\n\t<collaborateurs>\n\t\t<collaborateur collab_code=\"1\">\n\t\t\t<nom_collab>LAPORTE</nom_collab>\n\t\t\t<prenom_collab>SYLVAIN</prenom_collab>\n\t\t\t<intitule_collab>LAPORTE SYLVAIN</intitule_collab>\n\t\t</collaborateur>\n\t\t<collaborateur collab_code=\"2\">\n\t\t\t<nom_collab>BOURRIÉ</nom_collab>\n\t\t\t<prenom_collab>DIMITRI</prenom_collab>\n\t\t\t<intitule_collab>BOURRIÉ DIMITRI</intitule_collab>\n\t\t</collaborateur>\n\t\t<collaborateur collab_code=\"3\">\n\t\t\t<nom_collab>GALÈS</nom_collab>\n\t\t\t<prenom_collab>ALEXIS</prenom_collab>\n\t\t\t<intitule_collab>GALÈS ALEXIS</intitule_collab>\n\t\t</collaborateur>\n\t\t<collaborateur collab_code=\"4\">\n\t\t\t<nom_collab>PLAZA</nom_collab>\n\t\t\t<prenom_collab>LOU</prenom_collab>\n\t\t\t<intitule_collab>PLAZA LOU</intitule_collab>\n\t\t</collaborateur>\n\t</collaborateurs>\n</depute>\n</deputes>\n```\nIl est possible de tester votre service REST avec POSTMAN qui vous permettra de créer des collections d'appels API :        \n\n-   Lancer POSTMAN\n-   Créer un WORKSPACE avec :       \n    -   pour titre : OPENDATA_ASSEMBLEE_NATIONALE\n    -   pour description : Collection d'API lié à l'Open Data de l'Assemblée Nationale en mode Private\n-   Créer une collection COLLECTION_1\n-   Créer un appel GET_DEPUTE \n-   Entrer l'URI que vous désirez tester: http://localhost:8088/depute?depute_code=PA795596\n-   Cliquer sur SEND. Le résultat devra ressembler au suivant:\n\n![](img/postman_use.png)\n\nPour créer un consommateur pour le web service REST avec Talend, il suffit de créer le Job suivant:\n\n![](img/rest-consumer.png)\n\n\nConfigurer le *tRestClient* comme suit:\n\n![Configuration du consommateur REST](img/rest-cons-config.png)\n\nExécuter. Le résultat devrait ressembler à ceci:\n\n![Résultat du consommateur REST](img/rest-cons-result.png)\n\n:::\n\n# 4. Norme et bonne pratique\n\n::: {.justify}\n\nMoins vous utilisez de composants mieux c'est.\nPlus vous utilisez de job mieux c'est\nPlus vous variabilisée mieux c'est.\nMoins vous utlise de varibale mieux c'est\nPlus vous loggé mieux c'est\nMieux vous nommez et organiser le job mieux c'est.\n\n:::\n\n## 4.1\tVariable et groupe de contexte\n\n::: {.justify}\n\nNotion de réutilisation et de différentiation selon l'environnement permet des livraisons dans un autres environnement sans avoir à modifier toute les valeurs en dures\n\n:::\n\n### VARIABLE DE DIR\n\n### VARIABLE DE BDD\n\n### VARIABLE GLOBAL\n\n## 4.2\tLog\n\n::: {.justify}\n\nPermet de savoir ce qu'il se passe, d'identifier les probleme afin d'avoir une meilleur maitenance et suivie?\n\n:::\n\n### LOG DE DEBUT ET FIN DE TRAITEMENT\n\n### LOG D'ERREUR\n\n### LOG D'INFORMATION\n\n\n## 4.3\tRègle de nommage et esthétique\n\n::: {.justify}\n\nPermet la compréhension par un autre dévellopeur\n\n:::\n### NOMMAGE DES COMPOSANTS\n\n### NOMMAGE DES LIENS\n\n### NOMMAGE DES SOUS_JOBS\n\n# 5.\tDéploiement et dévollepement informatique\n\n::: {.justify}\n\nGénéralement pas sur windows mais sur serveur UNIX et pas sur son post mais sur un seveur distant\n\n:::\n\n## 5.1\tConstruction du job\n\n### CONSTRUCTION AVEC GROUPE DE CONTEXTE DE QUAL\n\n### CONSTRUCTION API\n\n### FILEZILLA \n\n## 5.2\tDéploiement et Unix\n\n### LANCEMENT SCRIPT\n\n### CHAINE CRON & ORDONNACEMENT\n\n### MAILTO\n\n## 5.3\tDevelopement collaboratif avec Git\n\n::: {.justify}\n\n[Source : @QDROUSIE]()\n\nIl est bien connu que la version Open Source de Talend, Talend Open Studio est mono-poste, c’est-à-dire qu’elle ne permet pas le travail collaboratif intégré à l’outil. Pour cela, il faut se diriger vers les solutions entreprises.        \nPourtant, avec un minimum d’esprit de développeur, il est possible de mettre manuellement les sources Talend sur Git.               \nEn effet, les jobs,métadonnées, contextes crées dans Talend sont stockés sous forme de fichiers dans un répertoire spécifique, appelé workspace (cette terminologie parlera bien sûr aux développeurs habitués à Eclipse).         \nTout fichier pouvant être versionné sur Git, rien n’empêche donc une mise sous contrôle Git de notre travail Talend.\n\n:::\n\n### INSTALLATION GIT\n\n::: {.justify}\n\nInstallez le client GIT adapté à votre système d’exploitation, avec les options par défaut (cliquez sur Next à chaque fois).       \nLien [git](https://git-scm.com/download/win)\n\n:::\n\n### INITIALISATION PROJET\n\n#### Création d’un projet en local et publication sur le GIT\n\nSuivez les étapes dans l’ordre :\n\n-   Démarrez Talend Open Studio en tant qu’administrateur\n-   Créez un projet dans votre workspace (celui par défaut se trouve dans le dossier du Studio)\n-   Créez un job, un contexte, une métadonnée ou tout autre élément, puis enregistrez et quittez le projet\n-   Dans BitBucket, créez un projet puis un dépôt (repository) à l’intérieur avec un fichier README.md par défaut, et enfin récupérez le lien\nHTTPS (ou SSH si vous avez paramétré une clé SSH) du dépôt\n-   Ouvrez le client GIT et placez-vous au niveau du workspace\n-   Configurez le GIT avec vos identifiants Bitbucket (dans le cas de l’utilisation d’un lien HTTPS)\n```git\ngit config --global user.name \"q_drousie\"\ngit config --global user.email quentin.drousie@daka-tec.com\n```\n-   Initialisez le repo GIT avec la commande\n```git\ngit init\n```\n-   Créez un fichier ***.gitignore*** à la racine du workspace en exécutant la commande\n```git\nvim .gitignore\n```\n-   Ajoutez le contenu suivant à personnaliser selon le nom de votre projet\n```git\n**/jobInfo.properties\n.JETEmitters/\n.Java/\n.metadata/\nPROJET/code/routines/system/*.*\nPROJET/temp/\nPROJET/sqlPatterns/\nPROJET/talend.project\nDans mon exemple, le contenu est\n**/jobInfo.properties\n.JETEmitters/\n.Java/\n.metadata/\nCOMMON/code/routines/system/*.*\nCOMMON/temp/\nCOMMON/sqlPatterns/\nCOMMON/talend.project\n```\n-   Ajoutez le lien (HTTPS ou SSH, voir plus haut) au dépôt\n```git\ngit remote add origin https://q_drousie@bitbucket.org/dakatec\n```\nMettez à jour vos sources avec la commande\n```git\ngit pull origin master\n```\nAjoutez vos modifications en cache avec la commande\n```git\ngit add .\n```\n-   Committez vos modifications avec un commentaire avec la commande    \n```git\ngit commit -m \"Votre commentaire\"\n```\n-   Publiez les modifications sur le GIT avec la commande\n```git\ngit push origin master\n```\n-   Sur BitBucket, dans le projet talend et le dépôt talend se trouve désormais un dossier COMMON (nom technique du projet Talend)  \n\n#### Récupération en local d’un projet versionné sur le GIT\n\nSuivez les étapes dans l’ordre :        \n\n-   Créez un workspace sur votre poste, à l’emplacement de votre choix        \n```git\nC:\\Users\\quent\\Documents\\DAKA-Tec\\Outils\\Talend\\workspace\n```\n\n-   Ouvrez le client GIT et placez-vous au niveau du répertoire nouvellement créé \n```git\ncd \"C:\\Users\\quent\\Documents\\DAKA-Tec\\Outils\\Talend\\workspace\"\n```\n-   Configurez le GIT avec vos identifiants Bitbucket (dans le cas de l’utilisation d’un lien HTTPS)   \n```git\ngit config --global user.name \"q_drousie\"\ngit config --global user.email quentin.drousie@daka-tec.com\n```\nSur BitBucket, récupérez le lien HTTPS (ou SSH si vous avez paramétré une clé SSH) du dépôt\n-   Dans mon exemple, le lien HTTPS du dépôt est   \n```git\nhttps://q_drousie@bitbucket.org/dakatec/talend.git\n```\n-   Clonez le dépôt dans le dossier workspace\n```git\ngit clone https://q_drousie@bitbucket.org/dakatec/talend.git\n```\n-   Vérifiez que le dépôt a bien été rapatrié  \n```git\nC:\\Users\\quent\\Documents\\DAKATec\\Outils\\Talend\\workspace\\talend\n```\n-   Démarrez Talend Open Studio en tant qu’administrateur       \n-   Changez le workspace au démarrage pour pointer vers le workspace que vous avez créé et alimenté dans les étapes précédentes (avec le \\talend au bout) et redémarrez Talend Open Studio               \n-   Créez un nouveau projet portant exactement le même nom que celui publié sur le GIT (dossier se trouvant à la racine du dépôt)                \n\n### CYCLE DE VIE PROJET\n\n#### Récupération en local de la dernière version d’un projet GIT\n\nSi vous avez déjà récupéré le projet en local et que vous souhaitez de nouveau développer dessus, il faut impérativement que vous mettiez à jour vos sources au préalable.\n    \nOuvrez le client GIT et exécutez les commandes\n\n```git\ngit config --global user.name \"q_drousie\"\ngit config --global user.email quentin.drousie@daka-tec.com\ncd \"Votre workspace\"\ngit remote add origin url_distante_de_votre_projet\ngit pull origin master\n```\n\n#### Publication sur le GIT de la dernière version d’un projet en local\n\nUne fois la dernière version du projet GIT récupéré en local et les développements effectués, poussez votre travail en retour sur le GIT.       \n\nOuvrez le client GIT et exécutez les commandes        \n\n```git\ngit config --global user.name \"q_drousie\"\ngit config --global user.email quentin.drousie@daka-tec.com\ncd \"Votre workspace\"\ngit add .\ngit commit -m \"Résumé de votre travail\"\ngit remote add origin url_distante_de_votre_projet\ngit push origin master\n```\n\n# ANNEXE\n\n| Type origine | Type cible | Fonction | \n|---------|:-----|------:|\n|String|\tInteger|\tInteger.parseInt(row1.myString)|\n|String|\tInteger|\t(new Integer(row1.myString)).toString()|\n|String|\tDate|\tTalendDate.parseDate(\"dd-MMyyyy\",row1.myString)|\n|String|\tBigDecimal|\tnew BigDecimal(row1.myString) where myString can include decimal places. For example, 99.00|\n|String|\tFloat|\tFloat.parseFloat(row1.myString)|\n|String|\tLong|\tLong.parseLong(row1.myString)|\n|Long|\tString|\trow1.myLong.toString()|\n|Integer|\tString|\tvariable+\"\" or variable.toString()|\n|Integer|\tLong|\trow1.myInteger.longValue()|\n|Integer|\tBigDecimal|\tnew BigDecimal(row1.myInteger)|\n|Integer|\tFloat|\tnew Float(row1.myInteger)|\n|Float|\tString|\trow1.myFloat.toString()|\n|Float|\tInteger|\tTo do this conversion you need to decide on arounding methods such as Math.round(),Math.ceil(), Math.floor() and then cast the result to Integer.|\n|Float|\tBigDecimal|\tnew BigDecimal(Float.toString(row1.myFloat))|\n|Date|\tString|\tTalendDate.formatDate(\"yy-MM-dd\",row1.myDate)|\n|BigDecimal|\tString|\trow1.myBigDecimal.toString()|\n|BigDecimal|\tInteger|\tAs with Float, BigDecimal can have decimal places, so will need to be rounded prior to casting toInteger.|\n\n: Tableau de conversion de type {#tbl-type}\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}