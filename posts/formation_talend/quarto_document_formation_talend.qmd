---
title: "Formation DATA"
subtitle: "Utilisation d'un ETL : Talend"
author:
    name: GOLLENTZ Quentin
    url: https://www.linkedin.com/in/quentin-gollentz-697993172/
    email: quentin.gollentz@daka-team.com
    affiliations:
        name: DAKA-TEAM
        url: https://www.linkedin.com/company/daka%E2%80%A2tec/
        city: Lille
        state: France
        postal-code: 5900
date: last-modified
date-format: "DD-MM-YYYY"
description: "Application sur l'Open Data de l'Assemblée Nationale"
title-block-banner: "#ECF4FA"
format: 
  html:
    code-fold: true
    embed-resources: true
    smooth-scroll: true
    theme: cosmo
    fontcolor: black
    toc: true
    toc-location: left
    toc-title: Summary
    toc-depth: 3
    html-math-method: katex
css: css/styles.css
bibliography: references.bib
---

# 0. Introduction et prérequis

Dans la suite du document, nous proposons des exercices qui sont liés les uns des autres.\
Il est donc nécessaire de suivre dans l'ordre le document car certains exercices sont conditionnés aux précédents.\
Nous proposons le traitement de données issus de l'Open Data de l'Assemblée Nationale, en vue de développer une API permettant d'obtenir les informations relatifs à un député.

Pour la réalisation des exercices, il sera nécessaire d'avoir :

-   Talend en version 7.3.1 pour faire des traitements informatiques
-   Notepad++ pour visualiser et éditer des fichiers
-   Dbeaver pour interagir avec une base de données
-   PostgreSQL pour disposer d'une base de données
-   Postman pour interagir avec des API
-   Connexion internet
-   Une compréhension basique de l'anglais technique
-   Une compréhension basique de la science des données
-   Une compréhension basique de l'informatique décisionnelle

# 1. Prise en main

## 1.1 Présentation

**L'ETL est un acronyme pour EXTRACT TRANSFORM AND LOAD.**

C'est un concept signifiant le chargement de données d'un point A vers un point B ou les données de A sont éventuellement transformé afin d'être chargés dans B.\
Un logiciel ETL (Extract, Transform, Load) permet d'extraire des données brutes depuis une base de données, pour ensuite les restructurer, et enfin les charger.\
Les premiers ETL ont fait leur apparition dans les années 1970, mais ont beaucoup évolué pour répondre aux nouveaux besoins liés à l'essor du Cloud, des [SaaS (logiciels en tant que service)](https://www.lebigdata.fr/definition-saas) et du Big Data.\
Désormais, les ETL doivent permettre l'ingestion en temps réel, l'enrichissement de données, la prise en charge de milliards de transactions. Ils prennent aussi en charge les données structurées ou non structurées en provenance de sources sur site ou sur le Cloud.\
De même, ces plateformes doivent désormais être scalables, flexibles, résistantes aux pannes, et sécurisées.

**Talend est donc un logiciel ETL de manière simplifier afin que le développeur ne s'occupe que de la partie règle de métier.**

## 1.2 Installation de l'outil

#### TALEND

-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :
    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)
-   **Etape 1** : Télécharger l'archive ***ESB_731.7z***
-   **Etape 2** : Extraire l'archive téléchargé précédemment à la racine du disque *C:/*

À la fin de ces étapes, vous devriez obtenir le dossier suivant :

![](img/resultat_installation_talend.png)

Également les sous-dossiers suivants :

![](img/resultat_installation_talend_subfolder.png)

#### JAVA

Talend peut être vu comme un générateur de code Java, ainsi il est donc nécessaire de disposer d'une version de machine java adapté à la version de Talend utilisé.

-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :
    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)
-   **Etape 1** : Télécharger l'archive ***jdk-20.zip***
-   **Etape 2** : Extraire l'archive téléchargé précédemment à la racine du disque *C:/*
-   **Etape 3** : Lancer une invite de commande (Rappel : cmd dans une fenêtre)
-   **Etape 4** : Lancer les commandes suivantes :
    -   `set PATH=C:\jdk-20\bin;%PATH%`       
        `java -version`       
        `where java`        

À la fin de ces étapes, vous devriez obtenir le résultat suivant :

![](img/resultat_installation_java.png)

#### NOTEPAD++

-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :
    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)
-   **Etape 1** : Télécharger l'archive ***Notepad++.7z***
-   **Etape 2** : Extraire l'archive téléchargé précédemment à la racine du disque *C:/*

À la fin de ces étapes, vous devriez obtenir le résultat suivant :

![](img/resultat_installation_notepad.png)

Également les sous-dossiers suivants :

![](img/resultat_installation_notepad_subfolder.png)

#### DBEAVER

-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :
    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)
-   **Etape 1** : Télécharger l'archive ***Dbeaver.7z***
-   **Etape 2** : Extraire l'archive téléchargé précédemment à la racine du disque *C:/*

À la fin de ces étapes, vous devriez obtenir le résultat suivant :

![](img/resultat_installation_dbeaver.png)

Également les sous-dossiers suivants :

![](img/resultat_installation_dbeaver_subfolder.png)
    
#### POSTGRESQL

Expliquer les procédures serait un peu compliqué et redondant par rapport à la documentation qu'on peut trouver sur le web.       
Vous pouvez suivre la procédure ici :  
[`postgresql`](https://www.postgresqltutorial.com/postgresql-getting-started/install-postgresql)                
    
Vous pouvez également regarder la vidéo ci-dessous :        

```{=html}
<video 
  src="video/postgresql_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

[Source : @waytolearn](https://www.youtube.com/watch?v=H_TFWZo-I5w)

#### POSTMAN

-   **Etape 0** : Se rendre sur le site suivant :
    -   [`postman`](https://www.postman.com/downloads/)
-   **Etape 1** : Télécharger l'archive ***Postman-win64-Setup.exe***
-   **Etape 2** : Double cliquez sur l'exécutable et laissez vous guider par l'assistant d’installation

À la fin de ces étapes, vous devriez obtenir le résultat suivant :

![](img/postman.png)

## 1.3 Présentation d'un WORKSPACE

[Les projet Talend sont stockés dans un espace de travail (workspace)](https://business-intelligence.developpez.com/faq/talend/?page=I).

Chaque projet Talend contient un ensemble de Jobs (traduit sous forme de "classe"), ces jobs Talend sont stockés dans un projet Talend.

Ci-dessous, vous verrez l'arborescence d'un projet Talend :

-   workspace
    -   projet1
        -   businessProcess (les Business Models)
        -   code (les Routines)
        -   configuration (les fichiers de configuration)
        -   context (les contextes)
        -   documentations (les documentations créés dans les jobs)
        -   images (les images des tMap par exemple)
        -   joblets (les joblets pour les version TIS)
        -   metadata (les metadata)
        -   process (les jobs)
        -   sqlPatterns (les patterns sql)
        -   temp (les fichiers temporaires)
    -   projet2
        -   businessProcess
        -   code
        -   ...

Avant de créer son premier WORKSPACE, il convient de lancer Talend Studio.\
En supposant que les étapes précédentes ont été respectées, il convient de :\

-   Se rendre dans ce chemin : *C:/ESB_731/Studio*        
-   Faire un double clic gauche sur l'exécutable ***TOS_ESB-win-x86_64.exe*** afin de démarrer Talend Studio.

Remarque : Il est recommandé de créer un Raccourci vers exécutable dans son Bureau afin d'éviter une navigation inutile. (Rappel : CTRL+C sur exécutable puis CTRL+V sur le Bureau)

À l'exécution vous devriez avoir la fenêtre suivante qui s'ouvre :

![](img/demarrage_talend.png) Par défaut, le WORKSPACE sera situé dans le chemin suivant :

-   *C:/ESB_731/Studio/workspace*

Pour pouvoir changer d'endroit, il convient de :

-   Cliquer sur : Gérer les connexions
-   Dans la partie Espace de travail : Mettre le chemin souhaité

![](img/set_workspace_path.png)

## 1.4 Présentation du Talend Studio

Rappel commande utile :

-   CTRL + A : Tout sélectionner
-   CTRL + C : Copier
-   CTRL + V : Coller
-   CTRL + Z : Revenir à l'état précédent une action
-   CTRL + Y : Revenir à l'état succèdent une action
-   CTRL + S : Sauvegarder


#### BARRE PRINCIPALE

![](img/barre_principale.png)

-   FICHIER : Permet de changer de WORKSPACE et de modifier les propriétés du projet (Non utile)
-   EDITER : Revenir en arrière, Copier, Coller, ect… (Non utile)
-   FENÊTRE : 
    -   Modifier les éléments visuelles du Studio (Plutôt utile)
    -   Dans Préférences l’ensemble des paramètres pour les jobs du projet (Trop vaste pour être traité dans exhaustivité) (Très utile)


#### QUADRANT NORD OUEST

![](img/quadrant_nord_ouest.png) 
    
-   BUSINESS MODELS : (Aucune idée de l’utilité ou non)       
-   JOBS : L’endroit où l’on peut retrouver les différents JOB, par JOB on entend un traitement de données. Dans d’autres langage de programmation on parle de script.        
-   ROUTES : L’équivalent d’un Job mais le mode d’exécution n’est pas le même, un job sera lancé une fois tandis qu’une ROUTE est un service qui s’exécute en permanence        
-   SERVICES : On appelle cela communément une API permet de faire le lien avec d’autres application par exemple une BDD       
-   CONTEXTE : L’endroit om l’on peut retrouver les variables de contexte qui sont disponible à l’exécution du JOB que l’on oppose aux variables globales qui sont disponibles dans le Job        
-   RESSOURCE : (Aucune idée de l’utilité ou non)                
-   CODE : Permet de faire du code Java que l’on pourra réutiliser         
-   MODEL SQL : (Aucune idée de l’utilité ou non)       
-   METADONNE : L’endroit où l’on stocke les métadonnées des diverses sources de données possible :       
    -   BDD       
    -   Fichier Délimité        
    -   Fichier JSON        
    -   Ect ….        
        

#### QUADRANT NORD EST

![](img/quadrant_nord_est.png)        
    
L'endroit où nous allons créer les jobs qui prennent généralement des sources de données effectue des transformations en vue de les mettre dans une autre ou la même source de données.\
Nous verrons cela plus en détail dans les parties suivantes.

#### QUADRANT SUD OUEST

![](img/quadrant_sud_ouest.png)

-   APERCU DU CODE : (Aucune idée de l’utilité ou non)
-   OUTLINE : Ne prend sens que dans le cas où un job est ouvert. On retrouve ici l’ensemble des composants utilisées dans le job ouvert et les variables globales que ces composants génèrent.        
Ces variables peuvent être définis avant l’exécution du composant ou après.


#### QUADRANT SUD EST

-   COMPOSANT : Ne prend sens que dans le cas où un job est ouvert et qu’on à cliqué sur un composant. Dans cette fenêtre, nous allons paramétrer le composant afin que celui fonctionne selon nos besoins
-   CONTEXT : Permet de visualiser et de gérer l’ensemble des variables de contexte utilisés dans le job
-   EXECUTER LE JOB : Ne prend sens que dans le cas où un job est ouvert, il permet d’exécuter le traitement et d’afficher ce qui arrive dans la console. Une exécution en mode DEBUG est possible qui permet d’afficher l’ensemble des variables utilisées par le programme et leurs valeurs à l’instant T, il est également dans ce mode de faire une pause dans le traitement.


![](img/quadrant_sud_est.png)

## 1.5	Création d’un projet

Nous allons dans cette partie créé notre premier et unique projet.
Mais avant cela, nous allons créer un nouveau workspace qui sera utilisé dans la suite des exercices : 

-   **Etape 0** : Créer un dossier : *C:/workspace_talend*
-   **Etape 1** : Démarrer Talend
-   **Etape 2** : Cliquer sur Gérer les connexions et choisir le dossier créer en étape 0
-   **Etape 3** : Attendre que Talend redémarre
-   **Etape 4** : Créer un projet nommé : **OPENDATA_ASSEMBLEE_NATIONALE**

```{=html}
<video 
   src="video/init_workspace_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

# 2. Création de traitement

Un job peut être vu comme un ensemble de composant lié les uns aux autres et qui se lit de gauche à droite puis du haut vers le bas.

Les liens entre composants peuvent être de différentes natures :        

-   **Row** : Les lignes sont transférés de la sortie d'un composant à l'entrée d'un autres composant
    -   *Main* : L'ensemble des lignes sont transférés
    -   *Iterate* chaque ligne passe dans le composant de façon itérative
-   **If** : Le composant s'éxécute en fonction d'une condition testé à la fin de l'éxécution d'un autres composants

Par convention, on lit les composants de gauche à droite lorsque le lien est de type **Row** et de haut en bas lorsque le lien est de type **If**

Un [composant](https://www.axysweb.com/le-lexique-pour-comprendre-et-utiliser-le-studio-talend/) est un sous-ensemble d'un job qui effectue une opération définie. Par exemple : lire un fichier, filtrer des données ou encore extraire des données.

Un composant est composé d’un extrait de code Java généré automatiquement. Le but des composants est de gagner du temps en évitant le codage manuel pour effectuer les opérations de traitement de données courantes.

Talend propose une multitude de composants prêts à emploi regroupés un répertoire. Il est possible de développer des composants sur-mesure si Talend ne propose aucun composant répondant à votre besoin.

Ces composants nécessite un paramétrage, le paramétrage peut être définis selon deux façons :        

- **En dure** dans le sens où les valeurs associé aux paramètres du composant est définis par une valeur fixe écrit par le développeur
- **Avec variable** dans le sens où les valeurs associé aux paramètres du composant est définis par une valeur porté par une variable :
    - *contexte* : Disponible à l’exécution du job
    - *globale* : Définis dans le job

Les variables de contexte sont souvent utilisée pour porter les paramétrages de composant qu'on va appeler **metadata** et peuvent être définis à la main ou définis de façon automatique par Talend.

- **À la main** : 
  - AVANTAGE : CONTROLE 
  - DESAVANTAGE : VITESSE
- **Automatique** : 
  - AVANTAGE : VITESSE 
  - DESAVANTAGE : CONTROLE
  
:::{.callout-note}
Il est recommandé de laisser Talend définir les **metadata** et de corriger le résultat si celui-ci ne convient pas
:::
  
## 2.1	Fichier plat – Traitement des députés

### TELECHARGEMENT DU FICHIER

#### CREATION DU JOB

L'objectif ici est de télécharger le fichier source que nous allons utilisé par la suite.       
Nous allons créer un job avec :       

-   pour titre : DL_DATA_DEPUTE 
-   pour objectif : Téléchargement d’un fichier de type csv contenant les informations des députés
-   pour description le bloc suivant en remplaçant les {} par vos informations :        
    -     ##########                
          DATE DE CREATION : {dd/MM/yyyy}       
          DATE DE MODIFICATION :         
          VERSION : 0.1       
          AUTEUR : {nom_prenom}       
          DESCRIPTION  : CREATION DU JOB       
          ##########

Dossier dans lequel nous allons mettre des fichiers brut non généré par le job qu'il prend en entrée :    

-   *C:/workspace_talend/source/*

Dossier dans lequel nous allons mettre des fichiers généré par le job qu'il génère en sortie :        

-   *C:/workspace_talend/cible/*

Pour effectuer le téléchargement, nous allons utilisé le composant **tFileFetch** qui peut être trouvé soit dans la palette à droite, soit en tapant directement **tFileFetch** n'importe où dans le quadrant nord-est.


Soit le paramétrage suivant :

-     ##########
      URL : https://www.data.gouv.fr/fr/datasets/r/092bd7bb-1543-405b-b53c-932ebb49bb8e       
      METHODE : GET        
      NOM_FICHIER : depute.csv        
      CIBLE : C:/workspace_talend/source/depute/
      ARRET EN CAS D'ERREUR
      ##########

```{=html}
<video 
  src="video/first_job_fetch_file_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

#### EXECUTION DU JOB

Pour pouvoir exécuter un job, il convient de se mettre dans l'onglet "EXECUTER" dans le QUADRANT SUD EST.       
Ensuite il faut cliquer EXECUTER et observé qu'aucune erreur de compilation n'est généré.       
        
Les erreurs de compilation sont la conséquence d'un code mal écrit et se manifeste lors de la construction du job.       
Les erreurs d'éxécution  sont la conséquence d'un code mal écrit ou mal définis et se manifeste lors de l'éxécution du job.       

Il convient ensuite de s'assurer du bon fonctionnement du job.        
Ici nous souhaitons simplement télécharger un fichier csv dans un dossier, il convient donc de s'assurer que ce fichier est bien présent dans le dossier spécifié.

```{=html}
<video 
  src="video/launch_first_job_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

### LECTURE DU FICHIER

#### CREATION DU JOB

Nous allons dans cette partie créer un second job qui va lire le fichier télécharger par le premier.        
Nous allons créer un job avec :       

-   pour titre : READ_DATA_DEPUTE 
-   pour objectif : Lecture d'un fichier de type csv contenant les informations des députés et dans la description
-   pour description le bloc suivant en remplaçant les {} par vos informations :        
    -     ##########                
          DATE DE CREATION : {dd/MM/yyyy}       
          DATE DE MODIFICATION :         
          VERSION : 0.1       
          AUTEUR : {nom_prenom}       
          DESCRIPTION  : CREATION DU JOB       
          ##########    
      
      
La première chose à faire est de déterminer la structure du fichier.        
Pour cela nous allons l'ouvrir avec Notepad : 

```{=html}
<video 
  src="video/open_file_notepad_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Nous constatons le paramétrage :       

-     ##########
      ENTETE : Ligne 1       
      SEPARATION : Virgule      
      NOM_FICHIER : depute.csv       
      CIBLE : C:/workspace_talend/source/depute/
      ##########

AVec le schéma suivant : 

| Nom du champ | Type | Nullable | 
|---------|:-----|------:|
| id      | STRING   |    YES |
| legislature     | STRING  |   YES |  
| civ       | STRING    |     YES |
| nom       | STRING    |     YES |
| prenom       | STRING    |     YES |
| villeNaissance       | STRING    |     YES |
| naissance       | STRING    |     YES |
| age       | STRING    |     YES |
| groupe       | STRING    |     YES |
| groupeAbrev       | STRING    |     YES |
| departementNom       | STRING    |     YES |
| departementCode       | STRING    |     YES |
| datePriseFonction       | STRING    |     YES |
| mail       | STRING    |     YES |
| twitter       | STRING    |     YES |
| facebook       | STRING    |     YES |
| website       | STRING    |     YES |
| nombreMandats       | STRING    |     YES |
| experienceDepute       | STRING    |     YES |
| scoreParticipation       | STRING    |     YES |
| scoreParticipationSpecialite       | STRING    |     YES |
| scoreLoyaute       | STRING    |     YES |
| scoreMajorite       | STRING    |     YES |
| dateMaj       | STRING    |     YES |

: Structure du fichier

Nous avons dans un premier temps spécifié le type `STRING` pour l'ensemble des champs afin d'être sûr de bien pouvoir lire le fichier.        
En effet, le type `STRING` est le plus complet dans le sens où touts les types peuvent être convertis en `STRING`        
Voir @tbl-type.

Il convient maintenant de paramétrer le composant **tFileInputDelimited** afin qu'il sache comment lire le fichier.       

Nous effectuons ici un paramétrage à la main.        

```{=html}
<video 
  src="video/set_schema_a_la_mano_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Nous effectuons ici un paramétrage via l'utilisation d'une metadonnées définit par Talend.   
```{=html}
<video 
  src="video/set_schema_metadata_opt.mp4" 
  width="1000" 
  height="500">
</video>
```


#### EXECUTION DU JOB

Avant de lancer le job, il faut rajouter un composant **tLogRow** afin d'afficher les lignes lus dans la console d’exécution.
Pour cela, il convient :        

- Ajouter un composant **tLogRow** du côté droit du composant **tFileInputDelimited**
- Cliquer droit sur le composant **tFileInputDelimited** puis choisir un lien Row puis Main et le lier au composant **tLogRow**
- Exécuter le job pour observer les lignes lus par le composant **tFileInputDelimited** à travers le composant **tLogRow**

```{=html}
<video 
  src="video/execute_read_data_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

### TRANSFORMATION DE LA DONNEES

#### Etape 0 : Création d'un champ intitule

Nous allons maintenant transformé les données d'entrée avant de les imprimer dans .
Nous allons créer un nouveau champ que l'on va appelé :    

-    `intitule` : qui va concaténer le titre (Monsieur ou Madame) le nom et le prénom du député en question :                     
  - Soit `row1` la sorie du composant **tFileInputDelimited**       
    Nous avons alors `intitule = row1.cv + " " + row1.nom + " " + row1.prenom` 

Pour cela, nous allons utiliser un composant **tMap** qui prend une ou plusieurs sources en entrée, permet de faire des actions sur ces données afin de définir une ou plusieurs cibles de données.  

Ces actions peuvent être listées :        

- Transformation
- Jointure
- Filtre
- Selection

```{=html}
<video 
  src="video/transform_data_tmap_opt.mp4" 
  width="1000" 
  height="500">
</video>
```


#### Etape 1 : Modification DL_DATA_DEPUTE

Avant de voir une jointure, il convient de télécharger un deuxième fichier.
Il convient de mettre à jour le job DL_DATA_DEPUTE en spécifiant une mineur 0.2 et ajoutant à la description le bloc suivant :           

-     ##########                
      DATE DE CREATION : REPRENDRE LA DATE DE CREATION DU BLOC PRECEDENT      
      DATE DE MODIFICATION : {dd/MM/yyyy}        
      VERSION : 0.2       
      AUTEUR : {nom_prenom}       
      DESCRIPTION  : TELECHARGEMENT D'UN FICHIER SUPLLEMENTAIRE     
      ########## 


Ces divers bloc sont là pour tracer les diverses évolutions que peut rencontrer un flux.    

```{=html}
<video 
  src="video/modification_job_dl_log_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Maintenant il convient d'apporter la modification suivante :      

- Dupliquer le composant **tFileFetch** précédemment avec pour paramétrage :        
    -     ##########                
          URL : https://data.assemblee-nationale.fr/static/openData/repository/16/amo/collaborateurs_csv_opendata/liste_collaborateurs_excel.csv
          METHODE : GET 
          NOM_FICHIER : collaborateur.csv
          CIBLE : C:/workspace_talend/source/depute/
          ##########

- Lier l'éxécution du composant nouvellement créé avec l'ancien, en cliquant droit sur le premier composant, puis choisir *On Component Ok* pour cliquer gauche sur le nouveau compissant

- Renommer les composants :
  
    - **tFileFetch_1** en DL_DEPUTE
    - **tFileFetch_2** en DL_COLLAB

```{=html}
<video 
  src="video/dl_collab_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

On peut maintenant exécuter le job et s'assurer de la bonne présence du fichier **collaborateur.csv** dans le dossier **C:/workspace_talend/source/depute/**

![](img/realisation_dl_collab.png)

#### Etape 2 : Modification READ_DATA_DEPUTE

Il convient de mettre à jour le job READ_DATA_DEPUTE en spécifiant une mineur 0.2 et ajoutant à la description le bloc suivant :           

-     ##########                
      DATE DE CREATION : REPRENDRE LA DATE DE CREATION DU BLOC PRECEDENT      
      DATE DE MODIFICATION : {dd/MM/yyyy}        
      VERSION : 0.2       
      AUTEUR : {nom_prenom}       
      DESCRIPTION  : JOINTURE AVEC LES COLLABARATEUR     
      ########## 


Ces divers bloc sont là pour tracer les diverses évolutions que peut rencontrer un flux.        

La première chose à faire est de déterminer la structure du fichier.         
Pour cela nous allons l’ouvrir avec Notepad :

```{=html}
<video 
  src="video/open_file_notepad_bis_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Nous constatons le paramétrage:

-     ##########
      ENTETE : Ligne 1       
      SEPARATION : Point-Virgule      
      NOM_FICHIER : colaborateur.csv        
      CIBLE : C:/workspace_talend/source/depute/
      ##########

Avec le schéma suivant : 

| Nom du champ | Type | Nullable | 
|---------|:-----|------:|
| id (Identifiant du député)      | STRING   |    YES |
| nom_depute   | STRING  |   YES |  
| prenom_depute     | STRING    |     YES |
| nom_collab       | STRING    |     YES |
| prenom_collab       | STRING    |     YES |


: Structure du fichier

La première ligne est l'identifiant du **députés** qui va nous permettre de faire la jointure entre les deux fichiers.
Le `prénom` et le `nom` du **députés** sont déjà présent dans le fichier ***deputes.csv**, ainsi seul les informations du collaborateur vont être utile.

Maintenant il convient d'apporter la modification suivante :      

- Lire le nouveau fichier avec le schéma 
- Faire la jointure dans le **tMap**
- Ajouter les champs liées au collaborateur en sortie et plus précisément un champ `collab` qui va prendre le nom et prénom du collaborateur :       
  - Soit `row2` la sorie du composant **tFileInputDelimited** lié au fichier ***collaborateur.csv***         
    Nous avons alors `collab = row2.nom_collab + " " + row2.prenom_collab` 
- Renommer les composants Talend

```{=html}
<video 
  src="video/tentative_jointure_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Dans ce premier jet, la jointure n'a ramené aucune ligne parce que les valeurs des champs dans ***collaborateur.csv*** sont entourés par des double quote.                        
Il convient donc de les supprimer afin que l'on est le même format entre l'`id` du député du fichier **deputes.csv** et l'`id` du député du fichier **collaborateur.csv**

```{=html}
<video 
  src="video/jointure_collab_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Dans cette version, nous avons en entrée 578 députés et en sortie 577 ligne de couple député/collaborateur.

Cela n'est pas le résultat voulu, en effet un députés à au moins un collaborateur et souvent plus d'un.       
Néanmoins ce résultat est le signe d'une ligne d'un députés sans collaborateur

Nous allons donc récupérer l'ensemble des correspondance que l'on va écrire dans un fichier ***depute_collaborateur.csv*** et récupérer les collaborateur sans députés dans un fichier de ***rejet rejet_collaborateur.csv***.

- ***depute_collaborateur.csv*** :        
  -       ##########
          ENTETE : intitule;collaborateur      
          SEPARATION : Point-Virgule      
          NOM_FICHIER : depute_collaborateur.csv        
          CIBLE : C:/workspace_talend/cible/depute/ 
          ##########   

- ***rejet_collaborateur.csv*** :        
  -       ##########
          ENTETE : intitule;collaborateur      
          SEPARATION : Point-Virgule      
          NOM_FICHIER : rejet_collaborateur.csv        
          CIBLE : C:/workspace_talend/cible/depute/rejet
          ##########    

    
```{=html}
<video 
  src="video/jointure_collab_final_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Il semblerait que la ligne en rejet ne possède aucune information.        
Il va falloir investiguer plus en détails le fichier des députés.       
    
Nous pouvons observer un problème à la ligne 481 qui est en fait le fin de la ligne 480.        
Il faudrait mettre un processus de nettoyage de la données, cependant par économie de temps, nous allons considérer la correction manuelle suivante :       

```{=html}
<video 
  src="video/problème_ligne_81_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

#### Etape 3 : Création d'un fichier par groupe politique

Dans cette partie, nous allons utiliser le concept de variables globales ainsi que le principe d'itération.       

Nous allons lire le fichier ***deputes.csv*** une première fois avec un composant **tFileInputDelimited** puis récupérer une ligne par groupe politique distinct grâce à un composant **tUniqRow** en utilisant le champ `groupeAbrev` pour ensuite la stocker dans une variable global `groupe` grâce à un composant **tFlowToItererate** dont la valeur peut être récupéré en faisant appel dans du code Java avec `(String)globalMap.get("groupe")`.        

A chaque itération, nous allons relire le fichier députes cependant pour ne pas perdre l'itération nous devons préalablement connecter ce nouveau **tFileInputDelimited** à un composant **tJava** en mode *on Component OK*   lui-même lié au composant **tFlowToItererate** en mode *Iterate* .       
Nous réaliserons la jointure mais également l'application d'un filtre en sortie de tel manière à ce qu'on ne considère que le groupe politique en question avec  `row1.groupeAbrev.equals((String)globalMap.get("groupe"))` dans un **tMap** afin de construire les fichiers :       

-   ***depute_collaborateur_ +  (String)globalMap.get("groupe") + ".csv*** :        
    -     ##########                
          ENTETE : intitule;collab      
          SEPARATION : Point-Virgule      
          NOM_FICHIER : depute_collaborateur_ +  (String)globalMap.get("groupe") + ".csv        
          CIBLE : C:/workspace_talend/cible/depute/      
          ##########
 
-   ***rejet_collaborateur_ +  (String)globalMap.get("groupe") + ".csv*** :       
    -     ##########
          ENTETE : nom_depute;prenom_depute;nom_collaborateur;prenom_collaborateur      
          SEPARATION : Point-Virgule      
          NOM_FICHIER : rejet_collaborateur_ +  (String)globalMap.get("groupe") + ".csv        
          CIBLE : C:/workspace_talend/cible/depute/rejet 
          ########## 

```{=html}
<video 
  src="video/collab_jointure_par_groupe_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

## 2.2	Fichier JSON – Traitement des données de votes

### TELECHARGEMENT DU FICHIER

L’objectif ici est de télécharger le fichier source que nous allons utilisé par la suite.       
Nous allons créer un job avec :       

-   pour titre : DL_DATA_VOTE       
-   pour objectif : Téléchargement d’un fichier de type json  contenant les informations de vote        
-   pour description le bloc suivant en remplaçant les {} par vos informations :    
    -     ##########                
          DATE DE CREATION : {dd/MM/yyyy}       
          DATE DE MODIFICATION :         
          VERSION : 0.1       
          AUTEUR : {nom_prenom}       
          DESCRIPTION  : CREATION DU JOB     
          ##########


Pour effectuer le téléchargement, nous allons utilisé le composant **tFileFetch** qui peut être trouvé soit dans la palette à droite, soit en tapant directement **tFileFetch** n’importe où dans le quadrant nord-est.

Soit le paramétrage suivant :

-       ##########
        URL : "http://data.assemblee-nationale.fr/static/openData/repository/16/loi/scrutins/Scrutins.json.zip"       
        METHODE : GET        
        NOM_FICHIER : "vote.zip"        
        CIBLE : "C:/workspace_talend/source/vote/" 
        ARRET EN CAS D'ERREUR
        ##########

Nous devons maintenant extraire l'archive, pour cela nous pouvons utiliser un composant **tFileUnarchive** avec pour paramétrage suivant :  

-       ##########                
        FICHIER D'ARCHIVE : C:/workspace_talend/source/vote/vote.zip       
        REPERTOIRE D'EXTRACTION  : C:/workspace_talend/source/vote/      
        ##########
        
        
- Lier l'éxécution du composant nouvellement créé avec l'ancien, en cliquant droit sur le premier composant, puis choisir *On Component Ok*

A la fin vous devriez avoir une liste de fichier JSON dans le dossier :       
*C:/workspace_talend/source/vote/json*

```{=html}
<video 
  src="video/get_json_data_opt.mp4" 
  width="1000" 
  height="500">
</video>
```


### LECTURE DU FICHIER

Nous allons dans cette partie créer un second job qui va lire le fichier télécharger par le premier.        
Nous allons créer un job avec :       

-   pour titre : READ_DATA_VOTE 
-   pour objectif : Lecture d'un fichier de type json contenant les informations des députés et dans la description
-   pour description le bloc suivant en remplaçant les {} par vos informations :        
    -     ##########                
          DATE DE CREATION : {dd/MM/yyyy}       
          DATE DE MODIFICATION :         
          VERSION : 0.1       
          AUTEUR : {nom_prenom}       
          DESCRIPTION  : CREATION DU JOB       
          ##########

La première chose à faire est de déterminer la structure du fichier ou plutôt d'un fichier quelconque.
Nous souhaitons récupérer :  

- L'ensemble des votes POUR dont les identifiants de ces votants sont présent dans l’élément `acteurRef` dans le noeud :          
    -   scrutin/ventilationVotes/organe/groupes/groupe/vote/decompteNominatif/**pours**/votant/
- L'ensemble des votes CONTRE dont les identifiants de ces votants sont présent dans l’élément `acteurRef` dans le noeud :       
    - scrutin/ventilationVotes/organe/groupes/groupe/vote/decompteNominatif/**contres**/votant/

Nous allons malheureusement définir deux metada pour le même fichier, en effet Talend ne gère qu'une boucle, or nous avons besoin de boucler sur les POUR, mais également les CONTRES.

```{=html}
<video 
  src="video/read_data_json_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Nous allons donc lire le même fichier avec un composant **tFileInputJSON** mais selon deux metadata différentes pour ensuite ajouter via un composant **tJavaRow** un champ `vote_code` avec pour valeur :        

-   1 si le députés est dans le noeud **POUR**
-   0 si le députés est dans le noeud **CONTRE**.

Nous allons ensuite réunir les deux jeux de données dans un composant **tUnite** avant d'écrire un fichier unique

- ***vote.csv*** :                

  -     ##########
        ENTETE : Ligne 1       
        SEPARATION : Point-Virgule      
        NOM_FICHIER : vote.csv     
        CIBLE : C:/workspace_talend/cible/vote/
        ##########

```{=html}
<video 
  src="video/read_data_vote_opt_final.mp4" 
  width="1000" 
  height="500">
</video>
```

### CREATION D'UN FICHIER GLOBAL DE VOTE

Le problème avec le flux précédent est que nous avons uniquement fait un traitement pour un fichier de la liste.        
Ainsi il va falloir pour chaque fichier de la liste faire cette action.

- Lister les fichier du répertoire *C:/workspace_talend/source/vote/json* avec un composant **tFileList** avec pour recherche le pattern `*.json`
- Lier ce composant avec un composant **tJava** en mode *Iterate*
- Lier le composant **tJava** au sous-job précédemment développer avec un lien *On Component OK*
- Mettre à jour les composants **tFileInputJSON** en modifiant le fichier à lire par la variable globale `((String)globalMap.get("tFileList_1_CURRENT_FILEPATH"))`issus du composant **tFileList**
- Ajouter un champ `loi_code` avec pour valeur `((String)globalMap.get("tFileList_1_CURRENT_FILE"))` issus du composant **tFileList** 
- Mettre à jour le schéma des composant **tUnite** et **tFileOutputDelimited** afin de considérer le nouveau champ `loi_code`
- Mettre à jour le composant **tFileOutputDelimited** afin d'écrire les données à la suite du fichier existant

## 2.2	Base de données – Alimentation

Nous allons dans la suite créer un job ALIM_BDD_OPENDATA_ASSEMBLEE_NATIONALE en nous inspirant des jobs :       

-   READ_DATA_DEPUTE        
-   READ_DATA_VOTE

L'idée est de remplacer la cible qui à la place d'être des fichiers vont être des tables.       
Nous souhaitons obtenir le MPD suivant :                
```{mermaid}
erDiagram
    COLLAB ||--|{ DEPUTE : rattachement 
    COLLAB {
        string depute_code PK "id du fichier collaborateur" 
        string nom_collab PK "nom_collab du fichier collaborateur avec MAJUSCULE & TRIM" 
        string prenom_collab PK "prenom_collab du fichier collaborateur avec MAJUSCULE & TRIM" 
    }
    DEPUTE }o--|{ VOTE : vote
    DEPUTE {
       string depute_code PK "id du fichier deputes"
       string nom_depute  "nom du fichier collaborateur avec MAJUSCULE & TRIM"
       string prenom_collab  "prenom du fichier collaborateur avec MAJUSCULE & TRIM"
    }
    VOTE {
      string depute_code PK "champ depute_code des fichiers de *.json"
      string loi_code PK "nom du fichier du fichier de vote"
      integer vote_code "champ construit dans le job READ_DATA_VOTE"
  }
```

### CREATION DE LA BDD

Avant de créer les tables, il convient de créer une base de données ainsi qu'un schéma dans lesquels nous allons construire nos différentes tables.       
Pour cela, il convient d'ouvrir PgAdmin, puis de construire une database avec pour nom `OPENDATA_ASSEMBLEE_NATIONALE` et un schema avec pour nom `dwh` :

Cela peut être réalisé via les commandes suivantes :
```SQL
DROP DATABASE IF EXISTS "OPENDATA_ASSEMBLEE_NATIONALE";

CREATE DATABASE "OPENDATA_ASSEMBLEE_NATIONALE"
    WITH 
    OWNER = postgres
    ENCODING = 'UTF8'
    LC_COLLATE = 'French_France.1252'
    LC_CTYPE = 'French_France.1252'
    TABLESPACE = pg_default
    CONNECTION LIMIT = -1;

COMMENT ON DATABASE "OPENDATA_ASSEMBLEE_NATIONALE"
    IS 'Base de données contenant les informations issus de l'OpenData de l'Assemblée Nationale';
    
DROP SCHEMA IF EXISTS dwh ;

CREATE SCHEMA IF NOT EXISTS dwh
    AUTHORIZATION postgres;
```

Maitenant que nous avons une BDD ainsi qu'un schém, nous pouvons créer les différentes tables :   

- Table DEPUTE :        
```SQL
CREATE TABLE dwh."DEPUTE" (
	depute_code varchar(20) NOT NULL,
	loi_code varchar(250) NOT NULL,
	prenom_depute varchar(250) NULL
);
``` 

- Table COLLAB :        
```SQL
CREATE TABLE dwh."COLLAB" (
	depute_code varchar(20) NOT NULL,
	nom_collab varchar(250) NOT NULL,
	prenom_collab varchar(250) NOT NULL
);
```

- Table VOTE :        
```SQL
CREATE TABLE dwh."VOTE" (
	depute_code varchar(20) NOT NULL,
	loi_code varchar(250) NOT NULL,
	vote_code  integer NOT NULL
);
```
### ALIMENTATION DE LA BDD

Nous allons créer un job avec :       

-   pour titre : ALIM_BDD_OPENDATA_ASSEMBLEE_NATIONALE 
-   pour objectif : Alimentation de la BDD OPENDATA_ASSEMBLEE_NATIONALE 
-   pour description le bloc suivant en remplaçant les {} par vos informations :        
    -     ##########                
          DATE DE CREATION : {dd/MM/yyyy}       
          DATE DE MODIFICATION :         
          VERSION : 0.1       
          AUTEUR : {nom_prenom}       
          DESCRIPTION  : CREATION DU JOB       
          ##########
          
Nous réaliserons les étapes suivantes pour l'alimentation de la table VOTE:       

- Paramétrer la connexion à la BDD avec un composant **tPostrgreSQLConnection** avec pour paramétrage :        
  -     ##########
        HOST : localhost      
        BDD : OPENDATA_ASSEMBLEE_NATIONALE      
        PORT : 5432   
        SCHEMA : dwh
        PARAMETRES AVANCE : COMMIT AUTOMATIQUE
        ##########
- Copier l'ensemble du l'ensemble du job READ_DATA_VOTE qu'on lit au composant **tPostrgreSQLConnection** avec un lien *On Component OK*
- Changer la cible **tFileOutputDelimited** par un composant **tPostrgreSQLOutput** avec pour paramètrage :        
  -     ##########
        UTILISER LA CONNEXION
        TABLE : VOTE
        ACTION SUR LA TABLE : DEFAUT
        ACTION SUR LES DONNES : INSERT OU UPDATE
        ##########
        
Avec le schéma suivant : 

| Nom du champ | Type | Nullable | KEY
|---------|:-----|:-----|------:|
| depute_code      | STRING   |    NO |YES |
| loi_code   | STRING  |   NO |  YES |
| vote_code     | INTEGER    |     NO |NO |



### RECETTE DE LA BDD

## 2.3	API Rest – Récupération des informations liés à un députés

### CREATION D'UNE REQUETE

### CREATION D'UNE API

Nous allons maintenant créer le service REST. Pour cela, créer un nouveau job, qu'on appellera *GETINFO_OPENDATA_ASSEMBLEE_NATIONALE*, puis glisser les composants suivants:

* **tRestRequest** : Pour définir la requête REST que le client doit appeler
* **tPostgreSQLInput** : Table de la base de données. Dans la nouvelle connexion à la base de données que vous avez créé, sous *Schémas des tables*, glisser la table *user* vers le Job, puis choisir tMySQLInput dans la fenêtre de choix qui apparaît.

:::{.callout-note}
Je choisis ***tPostgreSQLInput*** car, dans mon cas, c'est une base de données PostgreSQL, et je veux juste lire son contenu, je vais donc y accéder en entrée (d'où le ***Input***).
:::

* **tFlowToIterate** : Pour effectuer une itération sur les données d'entrée et génèrer des variables globales.
* **tXMLMap** : Permet de router et transformer les flux entrants de la base de données vers le résultat de la requête.
* **tRestResponse** : Pour définir la réponse à envoyer à l'utilisateur suite à sa requête.
* **tLogRow** : Pour le log, bien sûr.

Le job aura l'allure suivante:

![Service REST](img/tp1/rest-service.png)

Nous désirons configurer le service de manière à ce que, quand un consommateur appelle l'URI:
`http://localhost:8088/depute?depute_code=`, le service retourne une réponse contenant les collaborateur (nom et prénom) de la base de données dont les ids figurent entre 1 et 3.

#### Configuration de tRestRequest
tRestRequest devra être configuré comme suit:

* La valeur de *Endpoint URL* devra être: `"http://localhost:8088/users"`
* Si vous avez connecté le tRestRequest avec le tFlowToIterate avec un lien appelé *getUsers*, vous devriez le retrouver dans la case *REST API Mapping*. Sinon, créez-le.
* Garder les informations par défaut de ce mapping (méthode GET, URI /, Produit XML ou JSON).
* En cliquant sur *getUsers*, un bouton avec trois petits points apparaît. Cliquez dessus.
* Ajouter les deux colonnes *from* et *to* représentant les deux paramètres de la requête. Prenez soin à ce que:

    * Leur type soit *int*
    * Leurs valeurs par défaut soient respectivement 1 et 3.


    !!! tip "Remarque"
        Ces valeurs seront utilisées dans le cas où le consommateur n'introduit pas de paramètres.

    * Leur commentaire ait la valeur: *query*


    !!! tip "Remarque"
        Cela indique que ces champs sont des paramètres de requête, pas définies dans le Path.

#### Configuration de user
Puisque le composant *user* a été créé à partir de la connexion à votre base MySQL, il contient déjà les informations de connexion nécessaires.

Il suffira dans notre cas de:

* Cliquer sur *Guess Schema*  pour charger le schéma de la base.
* Changer la requête pour qu'elle soit comme suit:

```sql
"SELECT * FROM `user` where id>="+globalMap.get("getUsers.from")+
                      " and id<="+globalMap.get("getUsers.to")
```

!!! tip "Remarque"
    globalMap est une variable globale permettant de stocker les informations de la requête, comme par exemple ses paramètres.

#### Configuration de tXMLMap
Cliquer deux fois sur la *tXMLMap* pour la configurer.

* Dans la colonne de droite, ajouter (si ce n'est déjà fait) une colonne intitulée *body* dont le type est *Document*.
* Cette colonne contient un élément *root*. Renommer cet élément pour *users*.
* Ajouter un sous-élément à *users* appelé *user*.
* Définir cet élément comme *loop Element*.
* Glisser-déplacer l'id de la colonne en entrée vers le *user*. Créez-le comme attribut du noeud cible.
* De même pour le *firstname* et *lastname*, qui seront, eux, des sous-éléments du noeud *user*.
* Dans la colonne de droite, cliquer sur la petite clef à molette (![](img/tp1/clef-molette.png)). Mettre la valeur de "All in one" à *true*. Cela permettra à toutes les données XML d'être écrites dans un seul flux.

La configuration finale sera donc comme suit:

![tXMLMap du Service REST](img/tp1/rest-txmlmap.png)

!!! tip "Indication"
    La configuration précédente va générer une réponse de la forme suivante:

    ```XML
    <users>
      <user id=1>
        <firstname> flen </firstname>
        <lastname> fouleni </lastname>
      </user>
      <user id=2>
        <firstname> flena </firstname>
        <lastname> foulenia </lastname>
      </user>
    <users>
    ```

Les autres composants devront rester tels qu'ils sont par défaut. Il suffira maintenant de lancer le service, en cliquant sur *Exécuter*.

### Tester le Service
#### Dans un navigateur
Pour tester le service, il suffit d'ouvrir un navigateur, et de taper la requête de votre choix.

Par exemple, la requête suivante : `http://localhost:8088/users?from=2&to=4` donnera:

```XML
  <users>
      <user id="2">
          <firstname>Souad</firstname>
          <lastname>Mezghenni</lastname>
      </user>
      <user id="3">
          <firstname>Mourad</firstname>
          <lastname>Lahwel</lastname>
      </user>
      <user id="4">
          <firstname>Monia</firstname>
          <lastname>Landolsi</lastname>
      </user>
  </users>
```
Si aucun paramètre n'est indiqué: `http://localhost:8088/users` cela donnera:

```XML
  <users>
      <user id="1">
          <firstname>Ahmed</firstname>
          <lastname>Ramzi</lastname>
      </user>
      <user id="2">
          <firstname>Souad</firstname>
          <lastname>Mezghenni</lastname>
      </user>
      <user id="3">
          <firstname>Mourad</firstname>
          <lastname>Lahwel</lastname>
      </user>
  </users>
```
#### Avec SOAPUI
### Tester le service SOAP
Il est possible de tester votre service REST avec *SOAPUI*.

* Lancer SOAPUI
* Cliquer sur l'icône REST en haut de la fenêtre principale
* Entrer l'URI que vous désirez tester: `http://localhost:8088/users?from=2&to=4`
* La fenêtre suivante devrait apparaître:

![SOAPUI REST request](img/tp1/soapui-rest-req.png)


* Cliquer sur la flèche verte. Le résultat devra ressembler au suivant:

![SOAPUI REST request-response](img/tp1/soapui-rest-req-resp.png)

## Consommateur du WebService REST

Pour créer un consommateur pour le web service REST avec Talend, il suffit de créer le Job suivant:

![Consommateur REST](img/tp1/rest-consumer.png)

Configurer le *tRestClient* comme suit:

![Configuration du consommateur REST](img/tp1/rest-cons-config.png)

Exécuter. Le résultat devrait ressembler à ceci:

![Résultat du consommateur REST](img/tp1/rest-cons-result.png)

### TEST AVEC POSTMAN

# 3. Norme et bonne pratique
Moins vous utilisez de composants mieux c'est.
Plus vous utilisez de job mieux c'est
Plus vous variabilisée mieux c'est.
Moins vous utlise de varibale mieux c'est
Plus vous loggé mieux c'est
Mieux vous nommez et organiser le job mieux c'est.

## 3.1	Variable et groupe de contexte

Notion de réutilisation et de différentiation selon l'environnement permet des livraisons dans un autres environnement sans avoir à modifier toute les valeurs en dures

### VARIABLE DE DIR

### VARIABLE DE BDD

### VARIABLE GLOBAL

## 3.2	Log

Permet de savoir ce qu'il se passe, d'identifier les probleme afin d'avoir une meilleur maitenance et suivie?

### LOG DE DEBUT ET FIN DE TRAITEMENT

### LOG D'ERREUR

### LOG D'INFORMATION


## 3.3	Règle de nommage et esthétique

Permet la compréhension par un autre dévellopeur

### NOMMAGE DES COMPOSANTS

### NOMMAGE DES LIENS

### NOMMAGE DES SOUS_JOBS

# 4.	Déploiement et dévollepement informatique

Généralement pas sur windows mais sur serveur UNIX et pas sur son post mais sur un seveur distant

## 4.1	Construction du job

### CONSTRUCTION AVEC GROUPE DE CONTEXTE DE QUAL

### CONSTRUCTION API

### FILEZILLA 

## 4.2	Déploiement et Unix

### LANCEMENT SCRIPT

### CHAINE CRON & ORDONNACEMENT

### MAILTO

## 4.3	Developement collaboratif avec Git 

### REPRENDRE LE DOCUMENT DE QUENTIN DROUSIE

# ANNEXE

| Type origine | Type cible | Fonction | 
|---------|:-----|------:|
|String|	Integer|	Integer.parseInt(row1.myString)|
|String|	Integer|	(new Integer(row1.myString)).toString()|
|String|	Date|	TalendDate.parseDate("dd-MMyyyy",row1.myString)|
|String|	BigDecimal|	new BigDecimal(row1.myString) where myString can include decimal places. For example, 99.00|
|String|	Float|	Float.parseFloat(row1.myString)|
|String|	Long|	Long.parseLong(row1.myString)|
|Long|	String|	row1.myLong.toString()|
|Integer|	String|	variable+"" or variable.toString()|
|Integer|	Long|	row1.myInteger.longValue()|
|Integer|	BigDecimal|	new BigDecimal(row1.myInteger)|
|Integer|	Float|	new Float(row1.myInteger)|
|Float|	String|	row1.myFloat.toString()|
|Float|	Integer|	To do this conversion you need to decide on arounding methods such as Math.round(),Math.ceil(), Math.floor() and then cast the result to Integer.|
|Float|	BigDecimal|	new BigDecimal(Float.toString(row1.myFloat))|
|Date|	String|	TalendDate.formatDate("yy-MM-dd",row1.myDate)|
|BigDecimal|	String|	row1.myBigDecimal.toString()|
|BigDecimal|	Integer|	As with Float, BigDecimal can have decimal places, so will need to be rounded prior to casting toInteger.|

: Tableau de conversion de type {#tbl-type}