---
title: "De l'utilisation de Talend pour l'OpenData de l'Assemblée Nationale"
subtitle: "Formation DATA"
author:
    name: GOLLENTZ Quentin
    url: https://www.linkedin.com/in/quentin-gollentz-697993172/
    email: quentin.gollentz@daka-team.com
    affiliations:
        name: DAKA-TEAM
        url: https://www.linkedin.com/company/daka%E2%80%A2tec/
        city: Lille
        state: France
        postal-code: 5900
date: last-modified
date-format: "DD-MM-YYYY"
description: "Application sur l'Open Data de l'Assemblée Nationale"
title-block-banner: "#ECF4FA"
format: 
  html:
    code-fold: true
    embed-resources: true
    smooth-scroll: true
    theme: cosmo
    fontcolor: black
    toc: true
    toc-location: left
    toc-title: Summary
    toc-depth: 3
    html-math-method: katex
css: css/styles.css
bibliography: references.bib
engine: knitr
---
```{css echo=FALSE}
.column {
text-align: center;
}
```
```{css, echo = FALSE}
.justify {
  text-align: justify !important
}
```

# 0. Introduction et prérequis

::: {.justify}

Dans la suite du document, nous proposons des exercices qui sont liés les uns des autres.       
Il est donc nécessaire de suivre dans l’ordre le document car certains exercices sont conditionnés aux précédents.        
Nous proposons le traitement de données issu de l’[Open Data de l’Assemblée Nationale](https://data.assemblee-nationale.fr/), en vue de développer une API permettant d’obtenir les informations relatives à un député. Nous réaliserons également une route permettant à un utilisateur de voter sur un texte de loi donné.       

Pour la réalisation des exercices, il sera nécessaire d’avoir :       

-   **Talend** en version 7.3.1 pour faire des traitements informatiques
    -   dont activemq
    -   dont apache camel
-   **Notepad++** pour visualiser et éditer des fichiers
-   **Dbeaver** pour interagir avec une base de données
-   **PostgreSQL** pour disposer d'une base de données
-   **Postman** pour interagir avec des API
-   **Git** pour le développement collaboratif (Éventuellement un compte **Bitbucket** ou **Github**)
-   Connexion internet
-   Une compréhension basique de l'anglais technique
-   Une compréhension basique de la science des données
-   Une compréhension basique de l’informatique décisionnelle
-   Une compréhension basique de la Politique

:::

# 1. Présentation

## 1.1 Présentation du principe ETL

### 1.1.1 Présentation du principe ESB
    
::: {.justify}
    
    
L'Enterprise Service Bus (ESB) est un modèle d'architecture logicielle qui prend en charge l'échange de données en temps réel entre des applications disparates. Les grandes entreprises disposent de plusieurs applications qui exécutent diverses fonctions en utilisant des modèles de données, des protocoles et des restrictions de sécurité différents. L'ESB facilite l'intégration des applications en effectuant des opérations telles que la transformation des données, la conversion des protocoles et le routage des messages. Les applications transmettent les données pertinentes à l'ESB, qui les convertit et les transmet à d'autres applications qui en ont besoin.

Talend ESB (Enterprise Service Bus), développé par la société Talend, permet le développement de bus applicatif de type middleware messaging et facilite grandement l'exposition de données via des API (Rest & SOAP)

:::

### 1.1.2 Présentation du principe ETL

::: {.justify}
C’est un concept signifiant le chargement de données d’un point A vers un point B ou les données de A sont éventuellement transformé afin d’être chargés dans B.       
Un logiciel ETL (Extract, Transform, Load) permet d’extraire des données brutes depuis une base de données, pour ensuite les restructurer, et enfin les charger.       
    
Les premiers ETL ont fait leur apparition dans les années 1970, mais ont beaucoup évolué pour répondre aux nouveaux besoins liés à l’essor du Cloud, des SaaS (logiciels en tant que service) et du Big Data.        
Désormais, les ETL doivent permettre l’ingestion en temps réel, l’enrichissement de données, la prise en charge de milliards de transactions. Ils prennent aussi en charge les données structurées ou non structurées en provenance de sources sur site ou sur le Cloud.        
    
De même, ces plateformes doivent désormais être scalables, flexibles, résistantes aux pannes, et sécurisées.        
    
La différence entre l’ETL et l’ELT réside dans le fait que les données sont transformées en informations décisionnelles et dans la quantité de données conservée dans les entrepôts.
    
-   L’ETL (Extract/Transform/Load) est une approche d’intégration qui recueille des informations auprès de sources distantes, les transforme en formats et styles définis, puis les charge dans des bases de données, sources de données ou entrepôts.

![](img/ETL.png)



-   L’ELT (Extract/Load/Tansform) extrait également des données à partir d’une ou plusieurs sources distantes, mais les charge ensuite dans l’entrepôt de données cible sans changement de format. Dans un processus ELT, la transformation des données s’effectue au sein de la base de données cible. L’ELT nécessite moins de sources distantes, uniquement leurs données brutes et non préparées.

![](img/ELT.png)


Les deux approches sont viables, mais les décideurs informatiques, lorsqu’ils créent une architecture de données, doivent prendre en compte les capacités internes et l’impact croissant des technologies Cloud.

**Talend ESB** (Enterprise Service Bus) est donc également un logiciel ETL de manière simplifier afin que le développeur ne s’occupe que de la partie règle de métier.

:::

### 1.1.3  Présentation de la différence entre ETL & ESB

::: {.justify}

L’ESB (Enterprise Service Bus) et l’ETL (Extract, Transform, Load) sont deux technologies positionnées sur le transport et la transformation de la donnée au sein du système d’information. Mais, historiquement, elles répondent à des objectifs différents. L’ESB permet des échanges de données fiables et sécurisés entre les différentes applications du SI tandis que l’ETL centralise et homogénéise les données de sources multiples vers une seule et même application de destination.

Concrètement, l’ESB est adaptée lorsqu’il s’agit de traiter une fréquence élevée de flux de données avec une volumétrie limitée. Plutôt orientée services, sa fonction est de transporter et décloisonner l’information pour la rendre accessible sur les différents outils métiers qui composent le SI.

Par ailleurs, l’ETL peut traiter un important volume de données de manière performante, mais sur un nombre d’échanges limité. Sa fonction est d’agréger toutes les informations pour traiter la donnée comme un ensemble standardisé. C'est une approche particulièrement adaptée pour les projets de Business Intelligence et de data warehousing.

:::

## 1.2 Présentation d’un workspace

::: {.justify}

Les projet Talend sont stockés dans un espace de travail (workspace)

Chaque projet Talend contient un ensemble de Jobs (traduit sous forme de “classe”), ces jobs Talend sont stockés dans un projet Talend.

Ci-dessous, vous verrez l’arborescence d’un projet Talend :       

-   workspace 
    -   projet1 
        -   businessProcess (les Business Models)
        -   code (les Routines)
        -   configuration (les fichiers de configuration)
        -   context (les contextes)
        -   documentations (les documentations créés dans les jobs)
        -   images (les images des tMap par exemple)
        -   joblets (les joblets pour les version TIS)
        -   metadata (les metadata)
        -   process (les jobs)
        -   sqlPatterns (les patterns sql)
        -   temp (les fichiers temporaires)
    -   projet2 
        -   businessProcess
        -   code
        -   …

Avant de créer son premier workspace , il convient de lancer Talend Studio.

En supposant que les étapes précédentes ont été respectées, il convient de : 

-   Se rendre dans ce chemin : *C:/ESB_731/Studio*
-   Faire un double clic gauche sur l’exécutable ***TOS_ESB-win-x86_64.exe*** afin de démarrer Talend Studio.


:::{.callout-tip}
Il est recommandé de créer un raccourci vers l'exécutable dans son Bureau afin d'éviter une navigation inutile.       
Rappel : CTRL+C sur l'exécutable puis CTRL+V sur le Bureau
:::

À l'exécution vous devriez avoir la fenêtre suivante qui s'ouvre :

![](img/demarrage_talend.png) Par défaut, le WORKSPACE sera situé dans le chemin suivant :

-   *C:/ESB_731/Studio/workspace*

Pour pouvoir changer d'endroit, il convient de :

-   Cliquer sur : Gérer les connexions
-   Dans la partie Espace de travail : Mettre le chemin souhaité

![](img/set_workspace_path.png)

:::

## 1.3 Présentation du Studio

::: {.justify}

Rappel commande utile :

-   CTRL + A : Tout sélectionner
-   CTRL + C : Copier
-   CTRL + V : Coller
-   CTRL + Z : Revenir à l'état précédant une action
-   CTRL + Y : Revenir à l'état succédant une action
-   CTRL + S : Sauvegarder

:::

### 1.3.1 Présentation de la Barre Principal

::: {.justify}

![](img/barre_principale.png)

-   FICHIER : Permets de changer de WORKSPACE et de modifier les propriétés du projet 
-   EDITER : Revenir en arrière, Copier, Coller, ect… 
-   FENÊTRE : 
    -   Modifier les éléments visuels du Studio 
    -   Modifier l’ensemble des paramètres pour les jobs du projet dans l'onglet [Préférences](https://help.talend.com/r/fr-FR/7.3/open-studio-user-guide/java-interpreter-path-talend) 

:::

### 1.3.2 Présentation du Quadrant Nord Ouest {#quad-no}

::: {.justify}

![](img/quadrant_nord_ouest.png) 
    
-   BUSINESS MODELS : (Aucune idée de l’utilité ou non)       
-   JOBS : L’endroit où l’on peut retrouver les différents JOB, par JOB on entend un traitement de données.       
-   ROUTES : La principale différence entre les ROUTES et les JOB est que lorsque vous démarrez une route, elle écoute ou STREAM indéfiniment les entrées (fichier, message, etc.), et chaque fois qu’elles sont disponibles, elles sont traitées et envoyées à destination, jusqu’à ce que la route soit arrêtée.
D’autre part, un JOB est un processus par lots ou BATCH qui est lancé à la demande pour gérer certaines entrées (fichiers, base de données, etc.) et se termine lorsque toutes les entrées sont traitées.

:::{.callout-tip}
Un point important à noter est que vous pouvez appeler des Jobs Talend à partir d'une Route Talend si vous le souhaitez.
:::

-   SERVICES : Un webservice est une fonction qui a pour rôle de mettre un disposition un service via internet. Le webservice est une interface entre deux applications, et leur permet tout comme l’API, de communiquer entre elles.
Le webservice permet à des applications de communiquer entre elles même si elles fonctionnent avec des langages différents. Les webservices les plus connus sont de types SOAP, REST et HTTP.

:::{.callout-tip}
Les services de type REST peuvent se développer de la même manière qu’un job, seule la construction et le déploiement divergent.
:::

:::{.callout-tip}
Fonctionnement d’un webservice : 

-   **Étape 1** : Un utilisateur sur un ordinateur ou un mobile fait une demande. On l’appelle le client. Sa demande représente une requête qui est envoyée dans un langage spécfique : XML, HTTP ou encore JSON.       
-   **Étape 2** : La requête issue du client est envoyée sur un serveur distant via un protocole de type SOAP, REST ou HTTP.
-   **Étape 3** : Le serveur va émettre une réponse qui aura le même format que celui du protocole de la demande.         
:::

     
-   CONTEXTE : L’endroit où l’on peut retrouver les variables de contexte qui sont disponibles à l’exécution du JOB que l’on oppose aux variables globales qui sont disponibles dans le JOB.       
Ces variables peuvent être regroupées dans une catégorie qu'on appelle GROUPE et peuvent prendre leurs valeurs en fonction d'un ENVIRONNEMENT.        

-   RESSOURCE : (Aucune idée de l’utilité ou non)                
-   CODE : Permets de faire du code Java que l’on pourra réutiliser, on appelle ce code ROUTINES.  

:::{.callout-note}
## Note

Par défaut un certain de nombre de ROUTINES sont disponibles :   

-   Mathematical : Permet de faire des opérations mathématiques sur des entiers ou des numeriques
-   TalendDate : Permet de faire des opérations sur des dates
-   StringHandling : Permet de faire des opérations sur des chaines de charactères
:::

-   MODEL SQL : (Aucune idée de l’utilité ou non)       
-   METADONNE : L’endroit où l’on stocke les **metadata** des diverses sources ou cibles de données possibles.      
On peut faire remarquer que ces **metadata** peuvent être paramètrées par des variables de contextes :       
    -   BDD       
    -   Fichier Délimité        
    -   Fichier JSON        
    -    …       

:::        

### 1.3.3 Présentation du Quadrant Nord Est {#quad-ne}

::: {.justify}

![](img/quadrant_nord_est.png)        
    
L'endroit où nous allons créer les jobs qui prennent généralement des sources de données effectue des transformations en vue de les mettre dans une autre ou la même source de données.\

Cette partie ne prend sens uniquement lorsqu'un JOB est ouvert.   
    
On importe des composants :       

- Via la palette à droite
- En cliquant n'importe où dans la fenêtre puis en écrivant le nom du composant que l'on souhaite importer.       
Par exemple : **tFileInputDelimited**
    
Dans l'onglet Code, on peut voir le code du job.        
Celui-ci n'est là qu'à titre informatif et ne peut être modifié, il permet néanmoins de détecter d'éventuel erreur de compilation. 

:::{.callout-warning}
Seule l’onglet Designer permet de développer.  
Ne permet de détecter les erreurs qui peuvent se produire dans l'éxécution du job
:::

![](img/quadrant_nord_est_bis.png)        
:::


### 1.3.4 Présentation du Quadrant Sud Ouest {#quad-so}

::: {.justify}

![](img/quadrant_sud_ouest.png)

-   APERCU DU CODE : (Aucune idée de l’utilité ou non)
-   OUTLINE : Ne prend sens que dans le cas où un JOB est ouvert.        
On retrouve ici l'ensemble des composants utilisés dans le JOB ouvert et les variables globales que ces composants génèrent.        
Ces variables peuvent être disponible avant ou pendant l’exécution du composant.

:::{.callout-tip}

## Utile

Les variables globales définis par les composants, peuvent être appelés une fois qu'elle ont été définis dans d'autres composants.       
:::

:::

### QUADRANT SUD EST {#quad-se}

::: {.justify}

-   COMPOSANT : Ne prend sens que dans le cas où un JOB est ouvert et qu’on a cliqué sur un composant.         
Dans cette fenêtre, nous allons paramétrer le composant afin que celui fonctionne selon nos besoins
![](img/quadrant_sud_est_2.png)


-   CONTEXT : Permet de visualiser et de gérer l’ensemble des variables de contexte utilisés dans le JOB
![](img/quadrant_sud_est_3.png)


-   EXECUTER LE JOB : Ne prend sens que dans le cas où un JOB est ouvert, il permet d’exécuter le traitement et d’afficher ce qui arrive dans la console.       
Une exécution en mode DEBUG est possible; une telle exécution permet d’afficher l’ensemble des variables utilisées par le programme et leurs valeurs à l’instant T.        
Il est également dans ce mode DEBUG de faire une pause dans le traitement.
Deux types d'erreur peuvent se produire :       
    -   Les erreurs de **compilation** sont la conséquence d'un code mal écrit et se manifeste lors de la construction du job.       
    -    Les erreurs dans l'**éxécution**  sont la conséquence d'un code mal écrit ou mal définis et se manifeste lors de l'éxécution du job. 


![](img/quadrant_sud_est_1.png)

:::

## 1.4 Présentation d'un JOB

::: {.justify}

Un job peut être vu comme un ensemble de composants liés les uns aux autres et se lit de gauche à droite puis du haut vers le bas ; à la manière de la lecture française.

Les liens entre composants peuvent être de différentes natures :        

-   **Row** : Les lignes sont transférés de la sortie d'un composant à l'entrée d'un autres composant
    -   *Main* : L'ensemble des lignes sont transférés
    -   *Iterate* : Chaque ligne passe dans le composant de façon itérative
-   **Trigger** : Le composant s'éxécute en fonction d'une condition testé à la fin de l'éxécution d'un autres composants
    -   *On Component OK/ERROR* : Le composant s'éxecute en fonction de si le composant précédent à réussi ou pas
    -   *On Subjob OK/ERROR* : Le composant s'éxecute en fonction de si le sous-job précédent càd une suite de composant lié en mode **Row** à réussi ou pas
    -   *If* : Le composant s'éxécute en fonction d'une condition qui retourne TRUE ou FALSE.

:::{.callout-note}

## Convention

On parle de sous-job lorsqu'une suite de composant est lié par des liens de type **Row**
:::

Par convention, on lit les composants de gauche à droite lorsque le lien est de type **Row** et de haut en bas lorsque le lien est de type **If**

Un [composant](https://www.axysweb.com/le-lexique-pour-comprendre-et-utiliser-le-studio-talend/) est un sous-ensemble d'un job qui effectue une opération définie. Par exemple : lire un fichier, filtrer des données ou encore extraire des données.

Un composant est composé d’un extrait de code Java généré automatiquement. Le but des composants est de gagner du temps en évitant le codage manuel pour effectuer les opérations de traitement de données courantes.

Talend propose une multitude de composants prêts à emploi regroupés un répertoire. Il est possible de développer des composants sur-mesure si Talend ne propose aucun composant répondant à votre besoin.

Ces composants nécessitent un paramétrage, le paramétrage peut être définis selon deux façons :        

- **En dure** dans le sens où les valeurs associé aux paramètres du composant est définis par une valeur fixe écrit par le développeur
- **Avec variable** dans le sens où les valeurs associé aux paramètres du composant est définis par une valeur porté par une variable :
    - *contexte* : Disponible à l’exécution du job
    - *globale* : Définis dans le job

Les variables de contexte sont souvent utilisée pour porter les paramétrages de composant.
Ces variables de contexte peuvent être regroupés dans un **GROUPE** et les valeurs portés par ces variables peuvent être définis en fonction d'**ENVIRONNEMENT**.       
Généralement, on définis au moins trois environnement.         
Prenons l'exemple d'un job visant à alimenter une BDD, on définis un groupe de contexte visant à porter les paramètres pour s'y connecter, on définit trois environnements :               

-   **DEV** :  BDD sur son poste permettant de faire son développement
-   **QUAL** : BDD sur un serveur dédié visant à simuler un traitement opérationnelle
-   **PROD** : BDD opérationnel

Certain composant peuvent être paramétrer via le concept de **metadata**, ce qui permet la réutilisation du composant avec le paramétrage associé.        
On oppose ce concept de **metada** au fait de paramétrer le composant dans le job lui-même.

Certains paramétrages peut être fait de façon partiellement automatique ou à la main.
C'est le cas notamment des composants de lecture de fichier, par exemple **tFileInputDelimited**

- **À la main** : 
  - AVANTAGE : CONTROLE 
  - DESAVANTAGE : VITESSE
- **Automatique** : 
  - AVANTAGE : VITESSE 
  - DESAVANTAGE : CONTROLE
  
:::{.callout-tip}

## Recommandation

Il est recommandé de laisser Talend définir les **metadata** et de corriger le résultat si celui-ci ne convient pas
:::

:::

# 2. Installation des outils

## 2.1 TALEND

::: {.justify}

-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :
    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)
-   **Etape 1** : Télécharger l'archive ***ESB_731.7z***
-   **Etape 2** : Extraire l'archive téléchargée précédemment à la racine du disque *C:/*

À la fin de ces étapes, vous devriez obtenir le dossier suivant :

![](img/resultat_installation_talend.png)

Également les sous-dossiers suivants :

![](img/resultat_installation_talend_subfolder.png)

:::

## 2.2 JAVA

::: {.justify}

Talend peut être vu comme un générateur de code Java, ainsi il est donc nécessaire de disposer d'une version de machine java adapté à la version de Talend utilisé.

-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :
    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)
-   **Etape 1** : Télécharger l'archive ***jdk-20.zip***
-   **Etape 2** : Extraire l'archive téléchargée précédemment à la racine du disque *C:/*
-   **Etape 3** : Lancer une invite de commande (Rappel : cmd dans une fenêtre)
-   **Etape 4** : Lancer les commandes suivantes :
    -   `set PATH=C:\jdk-20\bin;%PATH%`       
        `java -version`       
        `where java`        

À la fin de ces étapes, vous devriez obtenir le résultat suivant :

![](img/resultat_installation_java.png)
Une autre solution est de spécifier le JAVA a utilisé par TALEND.       

-   **Etape 0** : Se rendre dans le dossier d'installation suivant suivant *C:/ESB_731* :
-   **Etape 1** : Ouvrir le fichier `TOS_ESB-win-x86_64.ini` 
-   **Etape 2** : A début du fichier ajouter les deux lignes suivnantes : 
    -   `-vm`       
        `C:\Program Files\Java\jdk-20\bin`       

À la fin de ces étapes, vous devriez obtenir le résultat suivant :

![](img/resultat_installation_java_2.png)

:::

## 2.3 NOTEPAD++

::: {.justify}

-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :
    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)
-   **Etape 1** : Télécharger l'archive ***Notepad++.7z***
-   **Etape 2** : Extraire l'archive téléchargée précédemment à la racine du disque *C:/*

À la fin de ces étapes, vous devriez obtenir le résultat suivant :

![](img/resultat_installation_notepad.png)

Également les sous-dossiers suivants :

![](img/resultat_installation_notepad_subfolder.png)

On peut également télécharger des add-ons à Notepad :       

-   JSON Viewer : Pour mieux visualiser des fichiers JSON
-   XML Tools : Pour mieux visualiser des fichiers XML

Pour pouvoir installer un add-on, il convient de :        

-   **Etape 0** : Ouvrir Notepad
-   **Etape 1** : Cliquer *Modules d'extension*<*Gestionnaires des modules d'extension*
-   **Etape 2** : Rechercher JSON VIEWER puis cocher (Faire de même avec XML TOOLS)
-   **Etape 3** : Cliquer sur *Installer*

À la fin de ces étapes, vous devriez obtenir le résultat suivant :

![](img/notepad_addon.png)

:::

## 2.4 DBEAVER

::: {.justify}

-   **Etape 0** : Se rendre dans le dossier Google Drive suivant :
    -   [`google_drive`](https://drive.google.com/drive/folders/1B_jTobHpSz_h2LFBbwAunaaA0G_X3jQc)
-   **Etape 1** : Télécharger l'archive ***Dbeaver.7z***
-   **Etape 2** : Extraire l'archive téléchargée précédemment à la racine du disque *C:/*

À la fin de ces étapes, vous devriez obtenir le résultat suivant :

![](img/resultat_installation_dbeaver.png)

Également les sous-dossiers suivants :

![](img/resultat_installation_dbeaver_subfolder.png)
:::
    
## 2.5 POSTGRESQL

::: {.justify}

Expliquer les procédures serait un peu compliqué et redondant par rapport à la documentation qu'on peut trouver sur le web.       
Vous pouvez suivre la procédure ici :  
[`postgresql`](https://www.postgresqltutorial.com/postgresql-getting-started/install-postgresql)                

:::

## 2.6 POSTMAN

::: {.justify}

-   **Etape 0** : Se rendre sur le site suivant :
    -   [`postman`](https://www.postman.com/downloads/)
-   **Etape 1** : Télécharger l'archive ***Postman-win64-Setup.exe***
-   **Etape 2** : Double-cliquer sur l'exécutable et laissez vous guider par l'assistant d’installation

À la fin de ces étapes, vous devriez obtenir le résultat suivant :

![](img/postman.png)

:::

# 3. Création de traitement

## 3.1	WORKSPACE - Création d’un projet 

::: {.justify}

::: {.callout-note}

## Objectif 

Nous allons dans cette partie créée notre premier et unique projet.        

:::

-   **Etape 0** : Créer un dossier : *C:/workspace_talend*
-   **Etape 1** : Démarrer Talend
-   **Etape 2** : Cliquer sur "Gérer les connexions" et choisir le dossier *C:/workspace_talend* créé en étape 0
-   **Etape 3** : Attendre que Talend redémarre
-   **Etape 4** : Créer un projet nommé : **OPENDATA_ASSEMBLEE_NATIONALE**

::: {.callout-caution collapse="true"}

## Solution
```{=html}
<video 
   src="video/init_workspace_opt.mp4" 
  width="1000" 
  height="500">
</video>
```
::: 

:::

## 3.2 CSV – Traitement des données des députés

### TELECHARGEMENT DU FICHIER

#### CREATION DU JOB

::: {.justify}

::: {.callout-note}

## Objectif 

L'objectif ici est de télécharger le fichier source que nous allons utilisé par la suite.     

:::

::: {.callout-tip}

## Composant

-   **tFileFetch** : Ce composant récupère un fichier via un protocole donné (HTTP, HTTPS, FTP ou SMB).

:::

-   **Etape 0** : Créer un job avec :       
      -   pour titre : DL_DATA_DEPUTE 
      -   pour objectif : Téléchargement d’un fichier de type csv contenant les informations des députés
      -   pour description le bloc suivant en remplaçant les {} par vos informations :        
          -     ##########                
                DATE DE CREATION : {dd/MM/yyyy}       
                DATE DE MODIFICATION :         
                VERSION : 0.1       
                AUTEUR : {nom_prenom}       
                DESCRIPTION  : CREATION DU JOB       
                ##########

-   **Etape 1** : Créer un dossier dans lequel nous allons mettre des fichiers brut non généré par le job qu'il prend en entrée :    
    -   *C:/workspace_talend/source/*

-   **Etape 2** : Créer un dossier dans lequel nous allons mettre des fichiers généré par le job qu'il génère en sortie :        
    -   *C:/workspace_talend/cible/*

-   **Etape 3** : Pour effectuer le téléchargement, nous allons utilisé le composant **tFileFetch** qui peut être trouvé soit dans la palette à droite, soit en tapant directement **tFileFetch** n'importe où dans le [QUADRANT NORD EST](#quad-ne).        
Soit le paramétrage suivant :
    -     ##########
          URL : https://www.data.gouv.fr/fr/datasets/r/092bd7bb-1543-405b-b53c-932ebb49bb8e       
          METHODE : GET        
          NOM_FICHIER : depute.csv        
          CIBLE : C:/workspace_talend/source/depute/
          ARRET EN CAS D'ERREUR
          ##########

::: {.callout-caution collapse="true"}

## Solution 

```{=html}
<video 
  src="video/first_job_fetch_file_opt.mp4" 
  width="1000" 
  height="500">
</video>
```
:::

:::

#### EXECUTION DU JOB

::: {.justify}

::: {.callout-note}

## Objectif 

L'objectif ici est de vérifier la bonne éxécution du job.       
Ici nous souhaitons simplement télécharger un fichier csv dans un dossier, il convient donc de s'assurer que ce fichier est bien présent dans le dossier spécifié.

:::

-   **Etape 1** : Pour pouvoir exécuter un job, il convient de se mettre dans l'onglet "EXECUTER" dans le [QUADRANT SUD EST](#quad-se). 
-   **Etape 2** : Cliquer EXECUTER et observer qu'aucune erreur de compilation n'est générée.   
-   **Etape 3** : Vérifier la présence du fichier *C:/workspace_talend/source/depute/****depute.csv***.   
      
::: {.callout-caution collapse="true"}

## Solution
```{=html}
<video 
  src="video/launch_first_job_opt.mp4" 
  width="1000" 
  height="500">
</video>
```
:::

:::

### LECTURE DU FICHIER

#### CREATION DU JOB

::: {.justify}

::: {.callout-note}

## Objectif 
Nous allons dans cette partie créer un second job qui va lire le fichier télécharger par le premier. 
:::

::: {.callout-tip}

## Liste des composants

-   **tFileInputDelimited** : Ce composant lit un fichier délimité ligne par ligne, afin de le diviser en champs et d'envoyer ces champs au composant suivant, comme défini par le schéma.

:::

-   **Etape 0** : Créer un job avec :        
    -   pour titre : READ_DATA_DEPUTE 
    -   pour objectif : Lecture d'un fichier de type csv contenant les informations des députés et dans la description
    -   pour description le bloc suivant en remplaçant les {} par vos informations :        
        -     ##########                
              DATE DE CREATION : {dd/MM/yyyy}       
              DATE DE MODIFICATION :         
              VERSION : 0.1       
              AUTEUR : {nom_prenom}       
              DESCRIPTION  : CREATION DU JOB       
              ##########    
      
      
-   **Etape 1** : Déterminer la structure du fichier avec Notepad.
-   **Etape 2** : Lire le fichier *C:/workspace_talend/source/depute/****depute.csv***         
Avec un composant **tFileInputDelimited**  que nous allons spécifier de la façon suivante:                
     -  Le paramètrage        
        -     ##########                
              ENTETE : Ligne 1               
              SEPARATION : Virgule             
              NOM_FICHIER : depute.csv              
              CIBLE : C:/workspace_talend/source/depute/        
              ##########               
     -  Le schéma 
      
| Nom du champ | Type | Nullable | 
|---------|:-----|------:|
| id      | STRING   |    YES |
| legislature     | STRING  |   YES |  
| civ       | STRING    |     YES |
| nom       | STRING    |     YES |
| prenom       | STRING    |     YES |
| villeNaissance       | STRING    |     YES |
| naissance       | STRING    |     YES |
| age       | STRING    |     YES |
| groupe       | STRING    |     YES |
| groupeAbrev       | STRING    |     YES |
| departementNom       | STRING    |     YES |
| departementCode       | STRING    |     YES |
| datePriseFonction       | STRING    |     YES |
| mail       | STRING    |     YES |
| twitter       | STRING    |     YES |
| facebook       | STRING    |     YES |
| website       | STRING    |     YES |
| nombreMandats       | STRING    |     YES |
| experienceDepute       | STRING    |     YES |
| scoreParticipation       | STRING    |     YES |
| scoreParticipationSpecialite       | STRING    |     YES |
| scoreLoyaute       | STRING    |     YES |
| scoreMajorite       | STRING    |     YES |
| dateMaj       | STRING    |     YES |

: Structure du fichier député


::: {.callout-tip}

## Type des données

Nous avons dans un premier temps spécifié le type `STRING` pour l'ensemble des champs afin d'être sûr de bien pouvoir lire le fichier.        
En effet, le type `STRING` est le plus complet dans le sens où touts les types peuvent être convertis en `STRING`        
Voir @tbl-type.

:::


::: {.callout-caution collapse="true"}
## Solution

**Etape 1**

```{=html}
<video 
  src="video/open_file_notepad_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

**Etape 2**

Nous effectuons ici un paramétrage à la main.        

```{=html}
<video 
  src="video/set_schema_a_la_mano_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

**Etape 2 : Alternative**

Nous effectuons ici un paramétrage via l'utilisation d'une metadonnées définit par Talend.   
```{=html}
<video 
  src="video/set_schema_metadata_opt.mp4" 
  width="1000" 
  height="500">
</video>
```
:::

:::

#### EXECUTION DU JOB

::: {.justify}

::: {.callout-note}

## Objectif 

L'objectif ici est de vérifier la bonne éxécution du job.       
Ici nous souhaitons simplement lire  un fichier csv, il convient donc de s'assurer d'imprimer dans la console leslignes lus.

:::

::: {.callout-tip}

## Liste des composants

-   **tLogRow** : Ce composant affiche les données ou les résultats dans la console de la vue Run afin de monitorer les données traitées.

:::

-   **Etape 0** :  Ajouter un composant **tLogRow** du côté droit du composant **tFileInputDelimited**
-   **Etape 1** :  Cliquer droit sur le composant **tFileInputDelimited** puis choisir un lien Row puis Main et le lier au composant **tLogRow**
-   **Etape 2** :  Exécuter le job pour observer les lignes lus par le composant **tFileInputDelimited** à travers le composant **tLogRow**

::: {.callout-caution collapse="true"}
## Solution

```{=html}
<video 
  src="video/execute_read_data_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

:::

:::

### ACTION SUR LA DONNEES

::: {.justify}

Nous allons utiliser un composant **tMap** qui prend une ou plusieurs sources en entrée, permet de faire des actions sur ces données afin de définir une ou plusieurs cibles de données.  

Ces actions peuvent être listées :        

- Transformation
- Jointure
- Filtre
- Sélection

:::

#### TRANSFORMATION ET SELECTION

::: {.justify}

::: {.callout-note}

## Objectif 

L'objectif ici est de créer un nouveau champ qui donnerait l'intitule du depute.        
Exemple : M. GOLLENTZ QUENTIN       
Nous souhaitons également sélectionner quelque champs que l'on va mettre en majuscule, renommer et trimer(=Supprimer les espaces avant et après le dernier charactère)  

Plus précisément on veut créer un fichier en effectuant le mapping suivant : 

| Nom du source | Nom du champ cible | Fonction | 
|---------|:-----|------:|
| depute_code     | row1.id   |    / |
| nom_depute   | row1.nom  |   TRIM & MAJ |  
| prenom_depute     | row1.prenom    |     TRIM & MAJ  |
| intitule_depute       | row1.civ + " " + row1.nom + " " + row1.prenom        |     TRIM & MAJ  |
| groupe_politique       | row1.groupeAbrev     |     TRIM & MAJ  |
:::

::: {.callout-tip}

## Liste des composants et fonctions

-   **tFileInputDelimited** : Ce composant lit un fichier délimité ligne par ligne, afin de le diviser en champs et d'envoyer ces champs au composant suivant, comme défini par le schéma.      
-   **tMap** : Ce composant transforme et route des données à partir d'une ou plusieurs source(s) de données vers une ou plusieurs destination(s).        
-   **tFileOutputDelimited** : Ce composant écrit en sortie les données d'entrée dans un fichier délimité en respectant le schéma défini.

-   *MAJ* : StringHandling.UPCASE()
-   *TRIM* : StringHandling.TRIM()


:::

-   **Etape 0** : Créer un job avec :       
      -   pour titre : TRANSFORM_DATA_DEPUTE 
      -   pour objectif : Transformation du fichier deputes.csv
      -   pour description le bloc suivant en remplaçant les {} par vos informations :        
          -     ##########                
                DATE DE CREATION : {dd/MM/yyyy}       
                DATE DE MODIFICATION :         
                VERSION : 0.1       
                AUTEUR : {nom_prenom}       
                DESCRIPTION  : CREATION DU JOB       
                ##########
-   **Etape 2** : Lire le fichier *C:/workspace_talend/source/depute/****depute.csv*** de la même manière que dans le job READ_DATA_DEPUTE

::: {.callout-tip}
## Interet de la metada

On voit ici l'avantage de spécifié des metada.        
Si vous avez spécifié la metadata FICHIER_DEPUTE alors vous pouvez directement l'importer sans avoir à refaire le le paramétrage.              
Si non vous pouvez toujours copier le **tFileInputDelimited** du job READ_DATA_DEPUTE et le coller dans le nouveau job TRANSFORM_DATA_DEPUTE
:::

-   **Etape 3** :  Ajouter un composant **tMap** du côté droit du composant **tFileInputDelimited**
-   **Etape 4** :  Cliquer droit sur le composant **tFileInputDelimited** puis choisir un lien Row puis Main et le lier au composant **tMap**
-   **Etape 5** :  Dans le **tMap** créer une sortie `depute_transform` avec le mapping suivant :    

| Nom du source |Type source |  Nom du champ cible | Type cible | Fonction |        
|---------|:-----|:-----|------:|        
| depute_code     |STRING| row1.id   |STRING|    / |        
| nom_depute   |STRING| row1.nom  |STRING|   TRIM & MAJ |  
| prenom_depute     |STRING| row1.prenom    |STRING|     TRIM & MAJ  |
| intitule_depute       |STRING| row1.civ + " " + row1.nom + " " + row1.prenom        |STRING|     TRIM & MAJ  |
| groupe_politique       |STRING| row1.groupeAbrev     |STRING|     TRIM & MAJ  |

-   **Etape 6** :  Ajouter un composant **tFileOutputDelimited** du côté droit du composant **tMap** 
-   **Etape 7** :  Cliquer droit sur le composant **tMap** puis choisir un lien Row puis `depute_transform` et le lier au composant **tFileOutputDelimited**
-   **Etape 8** :  Paramètrer le composant **tFileOutputDelimited** de la façon suivante :        
    -       ##########
            ENTETE : depute_code;nom_depute;prenom_depute;intitule_depute;groupe_politique      
            SEPARATION : Point-Virgule      
            NOM_FICHIER : depute_collaborateur.csv        
            CIBLE : C:/workspace_talend/cible/depute/
            NE PAS RETOURNER D'ERREUR SI LE FICHIER EXISTSE
            ENCODAGE : UTF-8
            CREER LE REPERTOIRE SI IL N'EXISTE PAS
            ########## 

::: {.callout-caution collapse="true"}
## Solution
```{=html}
<video 
  src="video/transform_data_tmap_opt.mp4" 
  width="1000" 
  height="500">
</video>
```
:::

:::

#### JOINTURE

::: {.justify}

::: {.callout-note}

## Objectif 

Nous souhaitons avoir un fichier des collaborateurs des députés.        
Pour cela nous allons réaliser une jointure entre le fichier des deputes et un fichier des collaborateurs.

:::

-   **Etape 0** : Mettre à jour le job DL_DATA_DEPUTE en spécifiant une mineur 0.2 et ajoutant à la description le bloc suivant :       
      -     ##########                        
            DATE DE CREATION : {date_creation_1}             
            DATE DE MODIFICATION : {dd/MM/yyyy}               
            VERSION : 0.2              
            AUTEUR : {nom_prenom}              
            DESCRIPTION  : TELECHARGEMENT D'UN FICHIER SUPLLEMENTAIRE            
            ##########        
            DATE DE CREATION : {date_creation_1}              
            DATE DE MODIFICATION :                
            VERSION : 0.1           
            AUTEUR : {nom_prenom}               
            DESCRIPTION  : CREATION DU JOB            
            ##########
    
::: {.callout-tip}
## Utilité des descriptions

Ces divers bloc sont là pour tracer les diverses évolutions que peut rencontrer un flux.    
:::

- **Etape 2** : Dupliquer le composant **tFileFetch** avec pour paramétrage :        
    -     ##########                
          URL : https://data.assemblee-nationale.fr/static/openData/repository/16/amo/collaborateurs_csv_opendata/liste_collaborateurs_excel.csv
          METHODE : GET 
          NOM_FICHIER : collaborateur.csv
          CIBLE : C:/workspace_talend/source/depute/
          ##########

- **Etape 3** : Lier l'éxécution du composant nouvellement créé avec l'ancien, en cliquant droit sur le premier composant, puis choisir *On Component Ok* pour cliquer gauche sur le nouveau compissant
- **Etape 4** : Renommer les composants :
  
    - **tFileFetch_1** en DL_DEPUTE
    - **tFileFetch_2** en DL_COLLAB
- **Etape 5** : Executer le job et s'assurer de la bonne présence du fichier **collaborateur.csv** dans le dossier **C:/workspace_talend/source/depute/**


::: {.callout-caution collapse="true"}
## Solution
```{=html}
<video 
  src="video/modification_job_dl_log_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

```{=html}
<video 
  src="video/dl_collab_opt.mp4" 
  width="1000" 
  height="500">
</video>
```


![](img/realisation_dl_collab.png)

:::

:::

#### Etape 2 : Modification READ_DATA_DEPUTE

::: {.justify}

Il convient de mettre à jour le job READ_DATA_DEPUTE en spécifiant une mineur 0.2 et ajoutant à la description le bloc suivant :           

-     ##########                
      DATE DE CREATION : REPRENDRE LA DATE DE CREATION DU BLOC PRECEDENT      
      DATE DE MODIFICATION : {dd/MM/yyyy}        
      VERSION : 0.2       
      AUTEUR : {nom_prenom}       
      DESCRIPTION  : JOINTURE AVEC LES COLLABARATEUR     
      ########## 


Ces divers bloc sont là pour tracer les diverses évolutions que peut rencontrer un flux.        

La première chose à faire est de déterminer la structure du fichier.         
Pour cela nous allons l’ouvrir avec Notepad :

```{=html}
<video 
  src="video/open_file_notepad_bis_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Nous constatons le paramétrage:

-     ##########
      ENTETE : Ligne 1       
      SEPARATION : Point-Virgule      
      NOM_FICHIER : colaborateur.csv        
      CIBLE : C:/workspace_talend/source/depute/
      ##########

Avec le schéma suivant : 

| Nom du champ | Type | Nullable | 
|---------|:-----|------:|
| id (Identifiant du député)      | STRING   |    YES |
| nom_depute   | STRING  |   YES |  
| prenom_depute     | STRING    |     YES |
| nom_collab       | STRING    |     YES |
| prenom_collab       | STRING    |     YES |


: Structure du fichier

La première ligne est l'identifiant du **députés** qui va nous permettre de faire la jointure entre les deux fichiers.
Le `prénom` et le `nom` du **députés** sont déjà présent dans le fichier ***deputes.csv**, ainsi seul les informations du collaborateur vont être utile.

Maintenant il convient d'apporter la modification suivante :      

- Lire le nouveau fichier avec le schéma 
- Faire la jointure dans le **tMap**
- Ajouter les champs liées au collaborateur en sortie et plus précisément un champ `collab` qui va prendre le nom et prénom du collaborateur :       
  - Soit `row2` la sorie du composant **tFileInputDelimited** lié au fichier ***collaborateur.csv***         
    Nous avons alors `collab = row2.nom_collab + " " + row2.prenom_collab` 
- Renommer les composants Talend

```{=html}
<video 
  src="video/tentative_jointure_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Dans ce premier jet, la jointure n'a ramené aucune ligne parce que les valeurs des champs dans ***collaborateur.csv*** sont entourés par des double quote.                        
Il convient donc de les supprimer afin que l'on est le même format entre l'`id` du député du fichier **deputes.csv** et l'`id` du député du fichier **collaborateur.csv**

```{=html}
<video 
  src="video/jointure_collab_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Dans cette version, nous avons en entrée 578 députés et en sortie 577 ligne de couple député/collaborateur.

Cela n'est pas le résultat voulu, en effet un députés à au moins un collaborateur et souvent plus d'un.       
Néanmoins ce résultat est le signe d'une ligne d'un députés sans collaborateur

Nous allons donc récupérer l'ensemble des correspondance que l'on va écrire dans un fichier ***depute_collaborateur.csv*** et récupérer les collaborateur sans députés dans un fichier de ***rejet rejet_collaborateur.csv***.

- ***depute_collaborateur.csv*** :        
  -       ##########
          ENTETE : intitule;collaborateur      
          SEPARATION : Point-Virgule      
          NOM_FICHIER : depute_collaborateur.csv        
          CIBLE : C:/workspace_talend/cible/depute/ 
          ##########   

- ***rejet_collaborateur.csv*** :        
  -       ##########
          ENTETE : intitule;collaborateur      
          SEPARATION : Point-Virgule      
          NOM_FICHIER : rejet_collaborateur.csv        
          CIBLE : C:/workspace_talend/cible/depute/rejet
          ##########    

    
```{=html}
<video 
  src="video/jointure_collab_final_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Il semblerait que la ligne en rejet ne possède aucune information.        
Il va falloir investiguer plus en détails le fichier des députés.       
    
Nous pouvons observer un problème à la ligne 481 qui est en fait le fin de la ligne 480.        
Il faudrait mettre un processus de nettoyage de la données, cependant par économie de temps, nous allons considérer la correction manuelle suivante :       

```{=html}
<video 
  src="video/problème_ligne_81_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

:::

#### Etape 3 : Création d'un fichier par groupe politique

::: {.justify}

Dans cette partie, nous allons utiliser le concept de variables globales ainsi que le principe d'itération.       

Nous allons lire le fichier ***deputes.csv*** une première fois avec un composant **tFileInputDelimited** puis récupérer une ligne par groupe politique distinct grâce à un composant **tUniqRow** en utilisant le champ `groupeAbrev` pour ensuite la stocker dans une variable global `groupe` grâce à un composant **tFlowToItererate** dont la valeur peut être récupéré en faisant appel dans du code Java avec `(String)globalMap.get("groupe")`.        

A chaque itération, nous allons relire le fichier députes cependant pour ne pas perdre l'itération nous devons préalablement connecter ce nouveau **tFileInputDelimited** à un composant **tJava** en mode *on Component OK*   lui-même lié au composant **tFlowToItererate** en mode *Iterate* .       
Nous réaliserons la jointure mais également l'application d'un filtre en sortie de tel manière à ce qu'on ne considère que le groupe politique en question avec  `row1.groupeAbrev.equals((String)globalMap.get("groupe"))` dans un **tMap** afin de construire les fichiers :       

-   ***depute_collaborateur_ +  (String)globalMap.get("groupe") + ".csv*** :        
    -     ##########                
          ENTETE : intitule;collab      
          SEPARATION : Point-Virgule      
          NOM_FICHIER : depute_collaborateur_ +  (String)globalMap.get("groupe") + ".csv        
          CIBLE : C:/workspace_talend/cible/depute/      
          ##########
 
-   ***rejet_collaborateur_ +  (String)globalMap.get("groupe") + ".csv*** :       
    -     ##########
          ENTETE : nom_depute;prenom_depute;nom_collaborateur;prenom_collaborateur      
          SEPARATION : Point-Virgule      
          NOM_FICHIER : rejet_collaborateur_ +  (String)globalMap.get("groupe") + ".csv        
          CIBLE : C:/workspace_talend/cible/depute/rejet 
          ########## 

```{=html}
<video 
  src="video/collab_jointure_par_groupe_opt.mp4" 
  width="1000" 
  height="500">
</video>
```
:::

## 3.3	JSON – Traitement des données de votes

### TELECHARGEMENT DU FICHIER

::: {.justify}

L’objectif ici est de télécharger le fichier source que nous allons utilisé par la suite.       
Nous allons créer un job avec :       

-   pour titre : DL_DATA_VOTE       
-   pour objectif : Téléchargement d’un fichier de type json  contenant les informations de vote        
-   pour description le bloc suivant en remplaçant les {} par vos informations :    
    -     ##########                
          DATE DE CREATION : {dd/MM/yyyy}       
          DATE DE MODIFICATION :         
          VERSION : 0.1       
          AUTEUR : {nom_prenom}       
          DESCRIPTION  : CREATION DU JOB     
          ##########


Pour effectuer le téléchargement, nous allons utilisé le composant **tFileFetch** qui peut être trouvé soit dans la palette à droite, soit en tapant directement **tFileFetch** n’importe où dans le quadrant nord-est.

Soit le paramétrage suivant :

-       ##########
        URL : "http://data.assemblee-nationale.fr/static/openData/repository/16/loi/scrutins/Scrutins.json.zip"       
        METHODE : GET        
        NOM_FICHIER : "vote.zip"        
        CIBLE : "C:/workspace_talend/source/vote/" 
        ARRET EN CAS D'ERREUR
        ##########

Nous devons maintenant extraire l'archive, pour cela nous pouvons utiliser un composant **tFileUnarchive** avec pour paramétrage suivant :  

-       ##########                
        FICHIER D'ARCHIVE : C:/workspace_talend/source/vote/vote.zip       
        REPERTOIRE D'EXTRACTION  : C:/workspace_talend/source/vote/      
        ##########
        
        
- Lier l'éxécution du composant nouvellement créé avec l'ancien, en cliquant droit sur le premier composant, puis choisir *On Component Ok*

A la fin vous devriez avoir une liste de fichier JSON dans le dossier :       
*C:/workspace_talend/source/vote/json*

```{=html}
<video 
  src="video/get_json_data_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

:::

### LECTURE DU FICHIER

::: {.justify}

Nous allons dans cette partie créer un second job qui va lire le fichier télécharger par le premier.        
Nous allons créer un job avec :       

-   pour titre : READ_DATA_VOTE 
-   pour objectif : Lecture d'un fichier de type json contenant les informations des députés et dans la description
-   pour description le bloc suivant en remplaçant les {} par vos informations :        
    -     ##########                
          DATE DE CREATION : {dd/MM/yyyy}       
          DATE DE MODIFICATION :         
          VERSION : 0.1       
          AUTEUR : {nom_prenom}       
          DESCRIPTION  : CREATION DU JOB       
          ##########

La première chose à faire est de déterminer la structure du fichier ou plutôt d'un fichier quelconque.
Nous souhaitons récupérer :  

- L'ensemble des votes POUR dont les identifiants de ces votants sont présent dans l’élément `acteurRef` dans le noeud :          
    -   scrutin/ventilationVotes/organe/groupes/groupe/vote/decompteNominatif/**pours**/votant/
- L'ensemble des votes CONTRE dont les identifiants de ces votants sont présent dans l’élément `acteurRef` dans le noeud :       
    - scrutin/ventilationVotes/organe/groupes/groupe/vote/decompteNominatif/**contres**/votant/

Nous allons malheureusement définir deux metada pour le même fichier, en effet Talend ne gère qu'une boucle, or nous avons besoin de boucler sur les POUR, mais également les CONTRES.

```{=html}
<video 
  src="video/read_data_json_opt.mp4" 
  width="1000" 
  height="500">
</video>
```

Nous allons donc lire le même fichier avec un composant **tFileInputJSON** mais selon deux metadata différentes pour ensuite ajouter via un composant **tJavaRow** un champ `vote_code` avec pour valeur :        

-   1 si le députés est dans le noeud **POUR**
-   0 si le députés est dans le noeud **CONTRE**.

Nous allons ensuite réunir les deux jeux de données dans un composant **tUnite** avant d'écrire un fichier unique

- ***vote.csv*** :                

  -     ##########
        ENTETE : Ligne 1       
        SEPARATION : Point-Virgule      
        NOM_FICHIER : vote.csv     
        CIBLE : C:/workspace_talend/cible/vote/
        ##########

```{=html}
<video 
  src="video/read_data_vote_opt_final.mp4" 
  width="1000" 
  height="500">
</video>
```

:::

### CREATION D'UN FICHIER GLOBAL DE VOTE

::: {.justify}

Le problème avec le flux précédent est que nous avons uniquement fait un traitement pour un fichier de la liste.        
Ainsi il va falloir pour chaque fichier de la liste faire cette action.

- Lister les fichier du répertoire *C:/workspace_talend/source/vote/json* avec un composant **tFileList** avec pour recherche le pattern `*.json`
- Lier ce composant avec un composant **tJava** en mode *Iterate*
- Lier le composant **tJava** au sous-job précédemment développer avec un lien *On Component OK*
- Mettre à jour les composants **tFileInputJSON** en modifiant le fichier à lire par la variable globale `((String)globalMap.get("tFileList_1_CURRENT_FILEPATH"))`issus du composant **tFileList**
- Ajouter un champ `loi_code` avec pour valeur `((String)globalMap.get("tFileList_1_CURRENT_FILE"))` issus du composant **tFileList** 
- Mettre à jour le schéma des composant **tUnite** et **tFileOutputDelimited** afin de considérer le nouveau champ `loi_code`
- Mettre à jour le composant **tFileOutputDelimited** afin d'écrire les données à la suite du fichier existant

:::

## 3.4	POSTGRESQL – Alimentation de la base de données

::: {.justify}

Nous allons dans la suite créer un job ALIM_BDD_OPENDATA_ASSEMBLEE_NATIONALE en nous inspirant des jobs :       

-   READ_DATA_DEPUTE        
-   READ_DATA_VOTE

L'idée est de remplacer la cible qui à la place d'être des fichiers vont être des tables.       
Nous souhaitons obtenir le MPD suivant :                
```{mermaid}
erDiagram
    COLLAB ||--|{ DEPUTE : rattachement 
    COLLAB {
        integer collab_code PK "sequence incremental pour chaque depute_code"
        string depute_code PK "id du fichier collaborateur" 
        string nom_collab  "nom_collab du fichier collaborateur avec MAJUSCULE & TRIM" 
        string prenom_collab  "prenom_collab du fichier collaborateur avec MAJUSCULE & TRIM"
        string intitule_collab "nom_collab + prenom_collab du fichier collaborateur avec MAJUSCULE & TRIM"
    }
    DEPUTE }o--|{ VOTE : vote
    DEPUTE {
       string depute_code PK "id du fichier deputes"
       string nom_depute  "nom du fichier depute avec MAJUSCULE & TRIM"
       string prenom_depute  "prenom du depute collaborateur avec MAJUSCULE & TRIM"
       string intitule_depute  "prenom du fichier depute avec MAJUSCULE & TRIM"
       string groupe_politique  "prenom du fichier depute avec MAJUSCULE & TRIM"


    }
    VOTE {
      string depute_code PK "champ depute_code des fichiers de *.json"
      string loi_code PK "nom du fichier du fichier de vote"
      integer vote_code "champ construit dans le job READ_DATA_VOTE"
  }
```
:::

### CREATION DE LA BDD

::: {.justify}

Avant de créer les tables, il convient de créer une base de données ainsi qu'un schéma dans lesquels nous allons construire nos différentes tables.       
Pour cela, il convient d'ouvrir PgAdmin, puis de construire une database avec pour nom `OPENDATA_ASSEMBLEE_NATIONALE` et un schema avec pour nom `dwh` :

Cela peut être réalisé via les commandes suivantes :
```SQL
DROP DATABASE IF EXISTS "OPENDATA_ASSEMBLEE_NATIONALE";

CREATE DATABASE "OPENDATA_ASSEMBLEE_NATIONALE"
    WITH 
    OWNER = postgres
    ENCODING = 'UTF8'
    LC_COLLATE = 'French_France.1252'
    LC_CTYPE = 'French_France.1252'
    TABLESPACE = pg_default
    CONNECTION LIMIT = -1;

COMMENT ON DATABASE "OPENDATA_ASSEMBLEE_NATIONALE"
    IS 'Base de données contenant les informations issus de l'OpenData de l'Assemblée Nationale';
    
DROP SCHEMA IF EXISTS dwh ;

CREATE SCHEMA IF NOT EXISTS dwh
    AUTHORIZATION postgres;
```

Maitenant que nous avons une BDD ainsi qu'un schéma, nous pouvons créer les différentes tables :   

- Table DEPUTE :        
```SQL
CREATE TABLE dwh."DEPUTE" (
	depute_code varchar(20) NOT NULL,
	nom_depute varchar(250) NULL,
	prenom_depute varchar(250) NULL,
	intitule_depute varchar(250) NULL,
	groupe_politique varchar(250) NULL

);
``` 

- Table COLLAB :        
```SQL
CREATE TABLE dwh."COLLAB" (
  collab_code integer NOT NULL,
  depute_code varchar(20) NOT NULL,
  nom_collab varchar(250) NULL,
  prenom_collab varchar(250) NULL,
  intitule_collab varchar(250) NULL
);
```

- Table VOTE :        
```SQL
CREATE TABLE dwh."VOTE" (
	depute_code varchar(20) NOT NULL,
	loi_code varchar(250) NOT NULL,
	vote_code  integer NOT NULL
);
```

:::

### ALIMENTATION DE LA BDD

::: {.justify}

Nous allons créer un job avec :       

-   pour titre : ALIM_BDD_OPENDATA_ASSEMBLEE_NATIONALE 
-   pour objectif : Alimentation de la BDD OPENDATA_ASSEMBLEE_NATIONALE 
-   pour description le bloc suivant en remplaçant les {} par vos informations :        
    -     ##########                
          DATE DE CREATION : {dd/MM/yyyy}       
          DATE DE MODIFICATION :         
          VERSION : 0.1       
          AUTEUR : {nom_prenom}       
          DESCRIPTION  : CREATION DU JOB       
          ##########
          
#### Nous réaliserons les étapes suivantes pour l'alimentation de la table VOTE:       

- Paramétrer la connexion à la BDD avec un composant **tPostrgreSQLConnection** avec pour paramétrage :        
  -     ##########
        HOST : localhost      
        BDD : OPENDATA_ASSEMBLEE_NATIONALE      
        PORT : 5432   
        SCHEMA : dwh
        PARAMETRES AVANCE : COMMIT AUTOMATIQUE
        ##########
- Copier l'ensemble du l'ensemble du job READ_DATA_VOTE qu'on lit au composant **tPostrgreSQLConnection** avec un lien *On Component OK*
- Changer la cible **tFileOutputDelimited** par un composant **tPostrgreSQLOutput** avec pour paramètrage :        
  -     ##########
        UTILISER LA CONNEXION
        TABLE : VOTE
        ACTION SUR LA TABLE : DEFAUT
        ACTION SUR LES DONNES : INSERT OU UPDATE
        ##########
        
Avec le schéma suivant : 

| Nom du champ | Type | Nullable | KEY
|---------|:-----|:-----|------:|
| depute_code      | STRING   |    NO |YES |
| loi_code   | STRING  |   NO |  YES |
| vote_code     | INTEGER    |     NO |NO |

:::

####  Nous réaliserons les étapes suivantes pour l'alimentation de la table DEPUTE et de la table COLLAB:     

::: {.justify}

-   Copier et coller le sous-job du job READ_DATA_DEPUTE lié à la jointure et à l'alimentation des fichiers **deputes.csv**
-   Lier le sous-job d'alimentation de la table VOTE à ce nouveau job
-   Changer le **tMap** afin de réaliser le  mapping suivant :           

| Nom du source | Nom du champ cible | Fonction | 
|---------|:-----|------:|
| depute_code     | row1.id   |    / |
| nom_depute   | row1.nom  |   TRIM & MAJ |  
| prenom_depute     | row1.prenom    |     TRIM & MAJ  |
| intitule_depute       | row1.civ + " " + row1.nom + " " + row1.prenom        |     TRIM & MAJ  |
| groupe_politique       | row1.groupeAbrev     |     TRIM & MAJ  |

: Mapping DEPUTE

- Ajouter un composant **tUniqRow** en sortie DEPUTE du **tMap** avec pour identifiant unique l'attribut `depute_code`        
- Mettre en sortie un composant **tPostrgreSQLOutput** pour la sortie DEPUTE avec pour paramètrage :        
  -     ##########
        UTILISER LA CONNEXION
        TABLE : DEPUTE
        ACTION SUR LA TABLE : SUPPRIMER SI ELLE EXISTE ET LA CREER
        ACTION SUR LES DONNES : INSERT
        ##########

Avec le schéma suivant : 

| Nom du champ | Type | Nullable | KEY
|---------|:-----|:-----|------:|
| depute_code     | STRING   |    NO |
| nom_depute   | STRING  |   YES |  
| prenom_depute     | STRING    |     YES  |
| intitule_depute       | STRING        |    YES  |
| groupe_politique       | STRING    |    YES  |

-   Changer le **tMap** afin de réaliser le  mapping suivant :           


| Nom du source | Nom du champ cible | Fonction | 
|---------|:-----|------:|
| collab_code     | row1.id   |     Numeric.sequence() |
| depute_code     | row1.id   |    / |
| nom_collab   | row2.nom_collab  |   TRIM & MAJ |  
| prenom_collab     | row2.prenom_collab    |     TRIM & MAJ  |
| intitule_collab      | row2.nom_collab + " " + row2.prenom_collab        |     TRIM & MAJ  |


: Mapping COLLAB

- Mettre en sortie un composant **tPostrgreSQLOutput** pour la sortie COLLAB avec pour paramètrage :        
  -     ##########
        UTILISER LA CONNEXION
        TABLE : COLLAB
        ACTION SUR LA TABLE : SUPPRIMER SI ELLE EXISTE ET LA CREER
        ACTION SUR LES DONNES : INSERT
        ##########

Avec le schéma suivant : 

| Nom du champ | Type | Nullable | KEY
|---------|:-----|:-----|------:|
| collab_code     | STRING   |    NO |
| depute_code     | STRING   |    NO |
| nom_collab   | STRING  |   YES |  
| prenom_collab       | STRING    |     YES  |
| intitule_collab         | STRING        |    YES  |

:::

### RECETTE DE LA BDD

::: {.justify}

Dans cette partie, nous allons nous assurer que le job fonctionne bien.       
Pour cela nous allons utiliser DBeaver.        

:::{.callout-note}
Nous aurions pus nous contenter de PgAdmin cependant cette outils ne permet d'interagir qu'avec des base de données de type PostgreSQL, là où DBeaver permet d'interagir avec un grand nombre d'autre type.
:::

- Ouvrir Dbeaver
- Créer un dossier OPENDATA_ASSEMBLEE
- Créer une connexion PostgreSQL à la BDD OPENDATA_ASSEMBLEE_NATIONALE
- Double-cliquer sur les tables afin de visualiser les données

![](img/dbeaver_table.png)
:::

## 3.5	REST – Récupération des informations liés à un députés

::: {.justify}

[Source : @INSATUNISIA](https://insatunisia.github.io/TP-eServices/tp1/)

:::

### CREATION D'UNE REQUETE

::: {.justify}
:::

### CREATION D'UNE API

::: {.justify}

Nous allons maintenant créer le service REST. Pour cela, créer un nouveau job, qu'on appellera *GETINFO_OPENDATA_ASSEMBLEE_NATIONALE*, puis glisser les composants suivants:

* **tPostgreSQLConnection** : Pour définir la connexion à la BDD OPENDATA_ASSEMBLEE_NATIONALE
* **tRestRequest** : Pour définir la requête REST que le client doit appeler
* **tPostgreSQLInput** : Table de la base de données

:::{.callout-note}
Je choisis ***tPostgreSQLInput*** car, dans mon cas, c'est une base de données PostgreSQL, et je veux juste lire son contenu, je vais donc y accéder en entrée (d'où le ***Input***).
:::

* **tFlowToIterate** : Pour effectuer une itération sur les données d'entrée et génèrer des variables globales.
* **tXMLMap** : Permet de router et transformer les flux entrants de la base de données vers le résultat de la requête.
* **tRestResponse** : Pour définir la réponse à envoyer à l'utilisateur suite à sa requête.
* **tLogRow** : Pour le log, bien sûr.

Le job aura l'allure suivante:

![Service REST](img/rest-service.png)

Nous désirons configurer le service de manière à ce que, quand un consommateur appelle l'URI `http://localhost:8088/depute?depute_code=param` avec pour `param`, un identifiant de `depute`, le service retourne une réponse contenant les informations du député dont une liste des collaborateur.

#### Configuration de tRestRequest
tRestRequest devra être configuré comme suit:

* La valeur de *Endpoint URL* devra être: `"http://localhost:8088/depute"`
* Si vous avez connecté le tRestRequest avec le tFlowToIterate avec un lien appelé *getDepute*, vous devriez le retrouver dans la case *REST API Mapping*. Sinon, créez-le.
* Garder les informations par défaut de ce mapping (méthode GET, URI /, Produit XML ou JSON).
* En cliquant sur *getDepute*, un bouton avec trois petits points apparaît. Cliquez dessus.
* Ajouter les deux colonnes *depute_code* représentant le  paramètre de la requête. Prenez soin à ce que:

    * Son type soit *string*
    * La valeur par défaut soit de PA722142 .
    * Leur commentaire ait la valeur: *query*


:::{.callout-note}
La valeur par défaut est utilisée dans le cas où le consommateur n'introduit pas de paramètres.
:::


:::{.callout-note}
Le commentaire query indique que ce champ est un paramètre de requête, pas définie dans le Path.
:::

:::

#### Configuration de depute

::: {.justify}

Puisque le composant *depute* a été créé à partir de la connexion à votre base PostgreSQL, il contient déjà les informations de connexion nécessaires.

Il suffira dans notre cas de:

* Cliquer sur *Guess Schema*  pour charger le schéma de la base.
* Changer la requête pour qu'elle soit comme suit:

```sql
SELECT 

  D.depute_code,
  D.nom_depute,
  D.prenom_depute,
  D.intitule_depute ,
  D.groupe_politique,
  C.collab_code,
  C.nom_collab,
  C.prenom_collab,
  C.intitule_collab,
  V.loi_code,
  V.vote_code
  
FROM "DEPUTE" D

INNER JOIN "COLLAB" C
ON D.depute_code = C.depute_code

WHERE D.depute_code IN ("+ globalMap.get("getDepute.depute_code") + ")
```

:::{.callout-note}
 globalMap est une variable globale permettant de stocker les informations de la requête, comme par exemple ses paramètres.
:::

:::

#### Configuration de tXMLMap

::: {.justify}

Cliquer deux fois sur la *tXMLMap* pour la configurer.

* Dans la colonne de droite, ajouter (si ce n'est déjà fait) une colonne intitulée *body* dont le type est *Document*.
* Cette colonne contient un élément *root*. Renommer cet élément pour *députés*.
* Ajouter un sous-élément à *deputes* appelé *depute*
* Glisser-déplacer le depute_code de la colonne en entrée vers le *depute*. Créez-le comme attribut du noeud cible.
* De même pour le *prenom_depute*,*prenom_depute*,*groupe_politique*,*intitule_depute*, qui seront, eux, des sous-éléments du noeud *depute*.
* Ajouter un sous-élément à *collaborateurs* appelé *collaborateur*.
* Définir cet élément comme *loop Element*.
* Glisser-déplacer le collab_code de la colonne en entrée vers le *collaborateur*. Créez-le comme attribut du noeud cible.
* De même pour le *prenom_collab*,*prenom_collab*,*intitule_collab*, qui seront, eux, des sous-éléments du noeud *collaborateur*.
* Dans la colonne de droite, cliquer sur la petite clef à molette (![](img/clef-molette.png)). Mettre la valeur de "All in one" à *true*. Cela permettra à toutes les données XML d'être écrites dans un seul flux.

La configuration finale sera donc comme suit:

![tXMLMap du Service REST](img/rest-txmlmap.png)

:::{.callout-note}
La configuration précédente va générer une réponse de la forme suivante:
```XML
<?xml version="1.0" encoding="UTF-8"?>
<deputes>
    <depute depute_code="PA795596">
        <nom_depute>VANNIER</nom_depute>
        <prenom_depute>PAUL</prenom_depute>
        <intitule_depute>M. VANNIER PAUL</intitule_depute>
        <groupe_politique>LFI-NUPES</groupe_politique>
        <collaborateurs>
            <collaborateur collab_code="1">
                <nom_collab>MARZOUGUI</nom_collab>
                <prenom_collab>ANIS</prenom_collab>
                <intitule_collab>MARZOUGUI ANIS</intitule_collab>
            </collaborateur>
            <collaborateur collab_code="2">
                <nom_collab>FOUCAULT</nom_collab>
                <prenom_collab>CLÉMENCE</prenom_collab>
                <intitule_collab>FOUCAULT CLÉMENCE</intitule_collab>
            </collaborateur>
            <collaborateur collab_code="3">
                <nom_collab>AWAD ABDOU</nom_collab>
                <prenom_collab>MOHAMED</prenom_collab>
                <intitule_collab>AWAD ABDOU MOHAMED</intitule_collab>
            </collaborateur>
        </collaborateurs>
    </depute>
</deputes>
```
:::

Les autres composants devront rester tels qu'ils sont par défaut. Il suffira maintenant de lancer le service, en cliquant sur *Exécuter*.

:::

### CONSOMMATEUR DU WEBSERVICE

::: {.justify}

Pour tester le service, il suffit d'ouvrir un navigateur, et de taper la requête de votre choix.

Par exemple, la requête suivante : `http://localhost:8088/depute?depute_code=PA795596` donnera:

```XML
<?xml version="1.0" encoding="UTF-8"?>
<deputes>
    <depute depute_code="PA795596">
        <nom_depute>VANNIER</nom_depute>
        <prenom_depute>PAUL</prenom_depute>
        <intitule_depute>M. VANNIER PAUL</intitule_depute>
        <groupe_politique>LFI-NUPES</groupe_politique>
        <collaborateurs>
            <collaborateur collab_code="1">
                <nom_collab>MARZOUGUI</nom_collab>
                <prenom_collab>ANIS</prenom_collab>
                <intitule_collab>MARZOUGUI ANIS</intitule_collab>
            </collaborateur>
            <collaborateur collab_code="2">
                <nom_collab>FOUCAULT</nom_collab>
                <prenom_collab>CLÉMENCE</prenom_collab>
                <intitule_collab>FOUCAULT CLÉMENCE</intitule_collab>
            </collaborateur>
            <collaborateur collab_code="3">
                <nom_collab>AWAD ABDOU</nom_collab>
                <prenom_collab>MOHAMED</prenom_collab>
                <intitule_collab>AWAD ABDOU MOHAMED</intitule_collab>
            </collaborateur>
        </collaborateurs>
    </depute>
</deputes>
```
Si aucun paramètre n'est indiqué: `http://localhost:8088/depute` cela donnera:

```XML
<depute depute_code="PA722142">
	<nom_depute>RUFFIN</nom_depute>
	<prenom_depute>FRANÇOIS</prenom_depute>
	<intitule_depute>M. RUFFIN FRANÇOIS</intitule_depute>
	<groupe_politique>LFI-NUPES</groupe_politique>
	<collaborateurs>
		<collaborateur collab_code="1">
			<nom_collab>LAPORTE</nom_collab>
			<prenom_collab>SYLVAIN</prenom_collab>
			<intitule_collab>LAPORTE SYLVAIN</intitule_collab>
		</collaborateur>
		<collaborateur collab_code="2">
			<nom_collab>BOURRIÉ</nom_collab>
			<prenom_collab>DIMITRI</prenom_collab>
			<intitule_collab>BOURRIÉ DIMITRI</intitule_collab>
		</collaborateur>
		<collaborateur collab_code="3">
			<nom_collab>GALÈS</nom_collab>
			<prenom_collab>ALEXIS</prenom_collab>
			<intitule_collab>GALÈS ALEXIS</intitule_collab>
		</collaborateur>
		<collaborateur collab_code="4">
			<nom_collab>PLAZA</nom_collab>
			<prenom_collab>LOU</prenom_collab>
			<intitule_collab>PLAZA LOU</intitule_collab>
		</collaborateur>
	</collaborateurs>
</depute>
</deputes>
```
Il est possible de tester votre service REST avec POSTMAN qui vous permettra de créer des collections d'appels API :        

-   Lancer POSTMAN
-   Créer un WORKSPACE avec :       
    -   pour titre : OPENDATA_ASSEMBLEE_NATIONALE
    -   pour description : Collection d'API lié à l'Open Data de l'Assemblée Nationale en mode Private
-   Créer une collection COLLECTION_1
-   Créer un appel GET_DEPUTE 
-   Entrer l'URI que vous désirez tester: http://localhost:8088/depute?depute_code=PA795596
-   Cliquer sur SEND. Le résultat devra ressembler au suivant:

![](img/postman_use.png)

Pour créer un consommateur pour le web service REST avec Talend, il suffit de créer le Job suivant:

![](img/rest-consumer.png)


Configurer le *tRestClient* comme suit:

![Configuration du consommateur REST](img/rest-cons-config.png)

Exécuter. Le résultat devrait ressembler à ceci:

![Résultat du consommateur REST](img/rest-cons-result.png)

:::

# 4. Norme et bonne pratique

::: {.justify}

Moins vous utilisez de composants mieux c'est.
Plus vous utilisez de job mieux c'est
Plus vous variabilisée mieux c'est.
Moins vous utlise de varibale mieux c'est
Plus vous loggé mieux c'est
Mieux vous nommez et organiser le job mieux c'est.

:::

## 4.1	Variable et groupe de contexte

::: {.justify}

Notion de réutilisation et de différentiation selon l'environnement permet des livraisons dans un autres environnement sans avoir à modifier toute les valeurs en dures

:::

### VARIABLE DE DIR

### VARIABLE DE BDD

### VARIABLE GLOBAL

## 4.2	Log

::: {.justify}

Permet de savoir ce qu'il se passe, d'identifier les probleme afin d'avoir une meilleur maitenance et suivie?

:::

### LOG DE DEBUT ET FIN DE TRAITEMENT

### LOG D'ERREUR

### LOG D'INFORMATION


## 4.3	Règle de nommage et esthétique

::: {.justify}

Permet la compréhension par un autre dévellopeur

:::
### NOMMAGE DES COMPOSANTS

### NOMMAGE DES LIENS

### NOMMAGE DES SOUS_JOBS

# 5.	Déploiement et dévollepement informatique

::: {.justify}

Généralement pas sur windows mais sur serveur UNIX et pas sur son post mais sur un seveur distant

:::

## 5.1	Construction du job

### CONSTRUCTION AVEC GROUPE DE CONTEXTE DE QUAL

### CONSTRUCTION API

### FILEZILLA 

## 5.2	Déploiement et Unix

### LANCEMENT SCRIPT

### CHAINE CRON & ORDONNACEMENT

### MAILTO

## 5.3	Developement collaboratif avec Git

::: {.justify}

[Source : @QDROUSIE]()

Il est bien connu que la version Open Source de Talend, Talend Open Studio est mono-poste, c’est-à-dire qu’elle ne permet pas le travail collaboratif intégré à l’outil. Pour cela, il faut se diriger vers les solutions entreprises.        
Pourtant, avec un minimum d’esprit de développeur, il est possible de mettre manuellement les sources Talend sur Git.               
En effet, les jobs,métadonnées, contextes crées dans Talend sont stockés sous forme de fichiers dans un répertoire spécifique, appelé workspace (cette terminologie parlera bien sûr aux développeurs habitués à Eclipse).         
Tout fichier pouvant être versionné sur Git, rien n’empêche donc une mise sous contrôle Git de notre travail Talend.

:::

### INSTALLATION GIT

::: {.justify}

Installez le client GIT adapté à votre système d’exploitation, avec les options par défaut (cliquez sur Next à chaque fois).       
Lien [git](https://git-scm.com/download/win)

:::

### INITIALISATION PROJET

#### Création d’un projet en local et publication sur le GIT

Suivez les étapes dans l’ordre :

-   Démarrez Talend Open Studio en tant qu’administrateur
-   Créez un projet dans votre workspace (celui par défaut se trouve dans le dossier du Studio)
-   Créez un job, un contexte, une métadonnée ou tout autre élément, puis enregistrez et quittez le projet
-   Dans BitBucket, créez un projet puis un dépôt (repository) à l’intérieur avec un fichier README.md par défaut, et enfin récupérez le lien
HTTPS (ou SSH si vous avez paramétré une clé SSH) du dépôt
-   Ouvrez le client GIT et placez-vous au niveau du workspace
-   Configurez le GIT avec vos identifiants Bitbucket (dans le cas de l’utilisation d’un lien HTTPS)
```git
git config --global user.name "q_drousie"
git config --global user.email quentin.drousie@daka-tec.com
```
-   Initialisez le repo GIT avec la commande
```git
git init
```
-   Créez un fichier ***.gitignore*** à la racine du workspace en exécutant la commande
```git
vim .gitignore
```
-   Ajoutez le contenu suivant à personnaliser selon le nom de votre projet
```git
**/jobInfo.properties
.JETEmitters/
.Java/
.metadata/
PROJET/code/routines/system/*.*
PROJET/temp/
PROJET/sqlPatterns/
PROJET/talend.project
Dans mon exemple, le contenu est
**/jobInfo.properties
.JETEmitters/
.Java/
.metadata/
COMMON/code/routines/system/*.*
COMMON/temp/
COMMON/sqlPatterns/
COMMON/talend.project
```
-   Ajoutez le lien (HTTPS ou SSH, voir plus haut) au dépôt
```git
git remote add origin https://q_drousie@bitbucket.org/dakatec
```
Mettez à jour vos sources avec la commande
```git
git pull origin master
```
Ajoutez vos modifications en cache avec la commande
```git
git add .
```
-   Committez vos modifications avec un commentaire avec la commande    
```git
git commit -m "Votre commentaire"
```
-   Publiez les modifications sur le GIT avec la commande
```git
git push origin master
```
-   Sur BitBucket, dans le projet talend et le dépôt talend se trouve désormais un dossier COMMON (nom technique du projet Talend)  

#### Récupération en local d’un projet versionné sur le GIT

Suivez les étapes dans l’ordre :        

-   Créez un workspace sur votre poste, à l’emplacement de votre choix        
```git
C:\Users\quent\Documents\DAKA-Tec\Outils\Talend\workspace
```

-   Ouvrez le client GIT et placez-vous au niveau du répertoire nouvellement créé 
```git
cd "C:\Users\quent\Documents\DAKA-Tec\Outils\Talend\workspace"
```
-   Configurez le GIT avec vos identifiants Bitbucket (dans le cas de l’utilisation d’un lien HTTPS)   
```git
git config --global user.name "q_drousie"
git config --global user.email quentin.drousie@daka-tec.com
```
Sur BitBucket, récupérez le lien HTTPS (ou SSH si vous avez paramétré une clé SSH) du dépôt
-   Dans mon exemple, le lien HTTPS du dépôt est   
```git
https://q_drousie@bitbucket.org/dakatec/talend.git
```
-   Clonez le dépôt dans le dossier workspace
```git
git clone https://q_drousie@bitbucket.org/dakatec/talend.git
```
-   Vérifiez que le dépôt a bien été rapatrié  
```git
C:\Users\quent\Documents\DAKATec\Outils\Talend\workspace\talend
```
-   Démarrez Talend Open Studio en tant qu’administrateur       
-   Changez le workspace au démarrage pour pointer vers le workspace que vous avez créé et alimenté dans les étapes précédentes (avec le \talend au bout) et redémarrez Talend Open Studio               
-   Créez un nouveau projet portant exactement le même nom que celui publié sur le GIT (dossier se trouvant à la racine du dépôt)                

### CYCLE DE VIE PROJET

#### Récupération en local de la dernière version d’un projet GIT

Si vous avez déjà récupéré le projet en local et que vous souhaitez de nouveau développer dessus, il faut impérativement que vous mettiez à jour vos sources au préalable.
    
Ouvrez le client GIT et exécutez les commandes

```git
git config --global user.name "q_drousie"
git config --global user.email quentin.drousie@daka-tec.com
cd "Votre workspace"
git remote add origin url_distante_de_votre_projet
git pull origin master
```

#### Publication sur le GIT de la dernière version d’un projet en local

Une fois la dernière version du projet GIT récupéré en local et les développements effectués, poussez votre travail en retour sur le GIT.       

Ouvrez le client GIT et exécutez les commandes        

```git
git config --global user.name "q_drousie"
git config --global user.email quentin.drousie@daka-tec.com
cd "Votre workspace"
git add .
git commit -m "Résumé de votre travail"
git remote add origin url_distante_de_votre_projet
git push origin master
```

# ANNEXE

| Type origine | Type cible | Fonction | 
|---------|:-----|------:|
|String|	Integer|	Integer.parseInt(row1.myString)|
|String|	Integer|	(new Integer(row1.myString)).toString()|
|String|	Date|	TalendDate.parseDate("dd-MMyyyy",row1.myString)|
|String|	BigDecimal|	new BigDecimal(row1.myString) where myString can include decimal places. For example, 99.00|
|String|	Float|	Float.parseFloat(row1.myString)|
|String|	Long|	Long.parseLong(row1.myString)|
|Long|	String|	row1.myLong.toString()|
|Integer|	String|	variable+"" or variable.toString()|
|Integer|	Long|	row1.myInteger.longValue()|
|Integer|	BigDecimal|	new BigDecimal(row1.myInteger)|
|Integer|	Float|	new Float(row1.myInteger)|
|Float|	String|	row1.myFloat.toString()|
|Float|	Integer|	To do this conversion you need to decide on arounding methods such as Math.round(),Math.ceil(), Math.floor() and then cast the result to Integer.|
|Float|	BigDecimal|	new BigDecimal(Float.toString(row1.myFloat))|
|Date|	String|	TalendDate.formatDate("yy-MM-dd",row1.myDate)|
|BigDecimal|	String|	row1.myBigDecimal.toString()|
|BigDecimal|	Integer|	As with Float, BigDecimal can have decimal places, so will need to be rounded prior to casting toInteger.|

: Tableau de conversion de type {#tbl-type}



